<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.12.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Harmonize: RemappingBarrier&lt; OP_SET, ADR_TYPE &gt; Struct Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Harmonize
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.12.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search',true);
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('structRemappingBarrier.html',''); initResizable(true); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pub-attribs">Public Attributes</a> &#124;
<a href="#pub-static-attribs">Static Public Attributes</a> &#124;
<a href="structRemappingBarrier-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">RemappingBarrier&lt; OP_SET, ADR_TYPE &gt; Struct Template Reference</div></div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="barrier_8h_source.html">barrier.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-types" name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:aaabe79cf6f00070f41eab68516fa94f0" id="r_aaabe79cf6f00070f41eab68516fa94f0"><td class="memItemLeft" align="right" valign="top"><a id="aaabe79cf6f00070f41eab68516fa94f0" name="aaabe79cf6f00070f41eab68516fa94f0"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>AdrType</b> = ADR_TYPE</td></tr>
<tr class="separator:aaabe79cf6f00070f41eab68516fa94f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ac59e6e92e533e55c3544a07cf40b4e" id="r_a2ac59e6e92e533e55c3544a07cf40b4e"><td class="memItemLeft" align="right" valign="top"><a id="a2ac59e6e92e533e55c3544a07cf40b4e" name="a2ac59e6e92e533e55c3544a07cf40b4e"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>LinkAdrType</b> = <a class="el" href="structutil_1_1mem_1_1Adr.html">util::mem::Adr</a>&lt;AdrType&gt;</td></tr>
<tr class="separator:a2ac59e6e92e533e55c3544a07cf40b4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27ffe6829c485a359bf2e6423caf3b8c" id="r_a27ffe6829c485a359bf2e6423caf3b8c"><td class="memItemLeft" align="right" valign="top"><a id="a27ffe6829c485a359bf2e6423caf3b8c" name="a27ffe6829c485a359bf2e6423caf3b8c"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>QueueType</b> = <a class="el" href="structutil_1_1mem_1_1PoolQueue.html">util::mem::PoolQueue</a>&lt;<a class="el" href="structutil_1_1mem_1_1Adr.html">LinkAdrType</a>&gt;</td></tr>
<tr class="separator:a27ffe6829c485a359bf2e6423caf3b8c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9c5704633b72dac429b02d34b401510" id="r_ac9c5704633b72dac429b02d34b401510"><td class="memItemLeft" align="right" valign="top"><a id="ac9c5704633b72dac429b02d34b401510" name="ac9c5704633b72dac429b02d34b401510"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>UnionType</b> = <a class="el" href="unionPromiseUnion.html">PromiseUnion</a>&lt;OP_SET&gt;</td></tr>
<tr class="separator:ac9c5704633b72dac429b02d34b401510"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02a0b1899e040a89a91bd614b2fba9b1" id="r_a02a0b1899e040a89a91bd614b2fba9b1"><td class="memItemLeft" align="right" valign="top"><a id="a02a0b1899e040a89a91bd614b2fba9b1" name="a02a0b1899e040a89a91bd614b2fba9b1"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>PairPack</b> = <a class="el" href="structutil_1_1mem_1_1PairPack.html">util::mem::PairPack</a>&lt;AdrType&gt;</td></tr>
<tr class="separator:a02a0b1899e040a89a91bd614b2fba9b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7a625e178b6771894a1a290fdffd826" id="r_ae7a625e178b6771894a1a290fdffd826"><td class="memItemLeft" align="right" valign="top"><a id="ae7a625e178b6771894a1a290fdffd826" name="ae7a625e178b6771894a1a290fdffd826"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>PairType</b> = typename PairPack::PairType</td></tr>
<tr class="separator:ae7a625e178b6771894a1a290fdffd826"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ac7dc5d7f05c3d739a86355cae72ca893" id="r_ac7dc5d7f05c3d739a86355cae72ca893"><td class="memTemplParams" colspan="2"><a id="ac7dc5d7f05c3d739a86355cae72ca893" name="ac7dc5d7f05c3d739a86355cae72ca893"></a>
template&lt;typename PROGRAM &gt; </td></tr>
<tr class="memitem:ac7dc5d7f05c3d739a86355cae72ca893"><td class="memTemplItemLeft" align="right" valign="top">__device__ unsigned int&#160;</td><td class="memTemplItemRight" valign="bottom"><b>queue_count</b> (PROGRAM program, <a class="el" href="structutil_1_1mem_1_1PoolQueue.html">QueueType</a> queue)</td></tr>
<tr class="memdesc:ac7dc5d7f05c3d739a86355cae72ca893"><td class="mdescLeft">&#160;</td><td class="mdescRight">Counts the number of links in the given queue. This is only used for debugging purposes. <br /></td></tr>
<tr class="separator:ac7dc5d7f05c3d739a86355cae72ca893"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af56922448d27bb00b3e062edca4216c3" id="r_af56922448d27bb00b3e062edca4216c3"><td class="memTemplParams" colspan="2"><a id="af56922448d27bb00b3e062edca4216c3" name="af56922448d27bb00b3e062edca4216c3"></a>
template&lt;typename PROGRAM &gt; </td></tr>
<tr class="memitem:af56922448d27bb00b3e062edca4216c3"><td class="memTemplItemLeft" align="right" valign="top">__device__ void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>release_queue</b> (PROGRAM program, <a class="el" href="structutil_1_1mem_1_1PoolQueue.html">QueueType</a> queue, AdrType release_count)</td></tr>
<tr class="memdesc:af56922448d27bb00b3e062edca4216c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Releases a queue for execution. <br /></td></tr>
<tr class="separator:af56922448d27bb00b3e062edca4216c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a377e0b11a8034b1f48b10abc71d44fb4" id="r_a377e0b11a8034b1f48b10abc71d44fb4"><td class="memTemplParams" colspan="2">template&lt;typename PROGRAM &gt; </td></tr>
<tr class="memitem:a377e0b11a8034b1f48b10abc71d44fb4"><td class="memTemplItemLeft" align="right" valign="top">__device__ void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a377e0b11a8034b1f48b10abc71d44fb4">release_partial</a> (PROGRAM program, <a class="el" href="structutil_1_1mem_1_1PairPack.html">PairPack</a> pair)</td></tr>
<tr class="separator:a377e0b11a8034b1f48b10abc71d44fb4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a546068364f84907c4ecb7e2fd30ff336" id="r_a546068364f84907c4ecb7e2fd30ff336"><td class="memTemplParams" colspan="2"><a id="a546068364f84907c4ecb7e2fd30ff336" name="a546068364f84907c4ecb7e2fd30ff336"></a>
template&lt;typename PROGRAM &gt; </td></tr>
<tr class="memitem:a546068364f84907c4ecb7e2fd30ff336"><td class="memTemplItemLeft" align="right" valign="top">__device__ void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>release_full</b> (PROGRAM program)</td></tr>
<tr class="memdesc:a546068364f84907c4ecb7e2fd30ff336"><td class="mdescLeft">&#160;</td><td class="mdescRight">Releases the links in the full list. <br /></td></tr>
<tr class="separator:a546068364f84907c4ecb7e2fd30ff336"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc9aa106be170426eea8edb394dcb0fe" id="r_adc9aa106be170426eea8edb394dcb0fe"><td class="memTemplParams" colspan="2">template&lt;typename PROGRAM &gt; </td></tr>
<tr class="memitem:adc9aa106be170426eea8edb394dcb0fe"><td class="memTemplItemLeft" align="right" valign="top">__device__ void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#adc9aa106be170426eea8edb394dcb0fe">release_sweep</a> (PROGRAM program)</td></tr>
<tr class="separator:adc9aa106be170426eea8edb394dcb0fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ac7a5098b6d4a89f85f9520301bb2fa" id="r_a9ac7a5098b6d4a89f85f9520301bb2fa"><td class="memTemplParams" colspan="2"><a id="a9ac7a5098b6d4a89f85f9520301bb2fa" name="a9ac7a5098b6d4a89f85f9520301bb2fa"></a>
template&lt;typename PROGRAM &gt; </td></tr>
<tr class="memitem:a9ac7a5098b6d4a89f85f9520301bb2fa"><td class="memTemplItemLeft" align="right" valign="top">__device__ void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>append_full</b> (PROGRAM program, <a class="el" href="structutil_1_1mem_1_1Adr.html">LinkAdrType</a> address)</td></tr>
<tr class="memdesc:a9ac7a5098b6d4a89f85f9520301bb2fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Appends a full link at the given address to the full list. <br /></td></tr>
<tr class="separator:a9ac7a5098b6d4a89f85f9520301bb2fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb589fab108491bf44e319897f29e43b" id="r_afb589fab108491bf44e319897f29e43b"><td class="memTemplParams" colspan="2">template&lt;typename PROGRAM &gt; </td></tr>
<tr class="memitem:afb589fab108491bf44e319897f29e43b"><td class="memTemplItemLeft" align="right" valign="top">__device__ bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#afb589fab108491bf44e319897f29e43b">merge_links</a> (PROGRAM program, <a class="el" href="structutil_1_1mem_1_1PairPack.html">PairPack</a> &amp;dst, <a class="el" href="structutil_1_1mem_1_1PairPack.html">PairPack</a> &amp;src, bool claimed)</td></tr>
<tr class="separator:afb589fab108491bf44e319897f29e43b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c75f081a27904e358216e47dc1840f7" id="r_a5c75f081a27904e358216e47dc1840f7"><td class="memTemplParams" colspan="2">template&lt;bool CAN_RELEASE = true, typename PROGRAM &gt; </td></tr>
<tr class="memitem:a5c75f081a27904e358216e47dc1840f7"><td class="memTemplItemLeft" align="right" valign="top">__device__ void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a5c75f081a27904e358216e47dc1840f7">union_await</a> (PROGRAM program, OpDisc disc, typename PROGRAM::PromiseUnionType promise_union)</td></tr>
<tr class="separator:a5c75f081a27904e358216e47dc1840f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae19b28f54738fb8d3d52b2afdc36e7d5" id="r_ae19b28f54738fb8d3d52b2afdc36e7d5"><td class="memTemplParams" colspan="2">template&lt;bool CAN_RELEASE = true, typename PROGRAM , typename OP_TYPE &gt; </td></tr>
<tr class="memitem:ae19b28f54738fb8d3d52b2afdc36e7d5"><td class="memTemplItemLeft" align="right" valign="top">__device__ void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ae19b28f54738fb8d3d52b2afdc36e7d5">await</a> (PROGRAM program, <a class="el" href="structPromise.html">Promise</a>&lt; OP_TYPE &gt; promise)</td></tr>
<tr class="memdesc:ae19b28f54738fb8d3d52b2afdc36e7d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Awaits the barrier with th supplied promise.  <br /></td></tr>
<tr class="separator:ae19b28f54738fb8d3d52b2afdc36e7d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad434c872cdbe5c42bedbe19ff81564b1" id="r_ad434c872cdbe5c42bedbe19ff81564b1"><td class="memTemplParams" colspan="2">template&lt;typename PROGRAM &gt; </td></tr>
<tr class="memitem:ad434c872cdbe5c42bedbe19ff81564b1"><td class="memTemplItemLeft" align="right" valign="top">__device__ void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ad434c872cdbe5c42bedbe19ff81564b1">release</a> (PROGRAM program)</td></tr>
<tr class="separator:ad434c872cdbe5c42bedbe19ff81564b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5d485e3c922cd80d4def4d2db8c7ea8" id="r_ab5d485e3c922cd80d4def4d2db8c7ea8"><td class="memTemplParams" colspan="2">template&lt;typename PROGRAM &gt; </td></tr>
<tr class="memitem:ab5d485e3c922cd80d4def4d2db8c7ea8"><td class="memTemplItemLeft" align="right" valign="top">__device__ void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ab5d485e3c922cd80d4def4d2db8c7ea8">add_semaphore</a> (PROGRAM program, unsigned int delta)</td></tr>
<tr class="separator:ab5d485e3c922cd80d4def4d2db8c7ea8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77c9173db860ba0b33c4ef71647d4b3a" id="r_a77c9173db860ba0b33c4ef71647d4b3a"><td class="memTemplParams" colspan="2">template&lt;typename PROGRAM &gt; </td></tr>
<tr class="memitem:a77c9173db860ba0b33c4ef71647d4b3a"><td class="memTemplItemLeft" align="right" valign="top">__device__ void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a77c9173db860ba0b33c4ef71647d4b3a">sub_semaphore</a> (PROGRAM program, unsigned int delta)</td></tr>
<tr class="separator:a77c9173db860ba0b33c4ef71647d4b3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-static-methods" name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:aabe5bd0015158048475abcfa99274ceb" id="r_aabe5bd0015158048475abcfa99274ceb"><td class="memItemLeft" align="right" valign="top">static __host__ __device__ <a class="el" href="structRemappingBarrier.html">RemappingBarrier</a>&lt; OP_SET, ADR_TYPE &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aabe5bd0015158048475abcfa99274ceb">blank</a> (unsigned int sem_val)</td></tr>
<tr class="separator:aabe5bd0015158048475abcfa99274ceb"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-attribs" name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr class="memitem:ad944fdab30123caa204607596a3e784e" id="r_ad944fdab30123caa204607596a3e784e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structTaggedSemaphore.html">TaggedSemaphore</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad944fdab30123caa204607596a3e784e">semaphore</a></td></tr>
<tr class="separator:ad944fdab30123caa204607596a3e784e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80147e1e92deb03d02072b2bd45429bc" id="r_a80147e1e92deb03d02072b2bd45429bc"><td class="memItemLeft" align="right" valign="top"><a id="a80147e1e92deb03d02072b2bd45429bc" name="a80147e1e92deb03d02072b2bd45429bc"></a>
unsigned int&#160;</td><td class="memItemRight" valign="bottom"><b>count</b></td></tr>
<tr class="separator:a80147e1e92deb03d02072b2bd45429bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ec0c71ef7dc73f371217e33fad9c2ad" id="r_a2ec0c71ef7dc73f371217e33fad9c2ad"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structutil_1_1mem_1_1PoolQueue.html">QueueType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2ec0c71ef7dc73f371217e33fad9c2ad">full_list</a></td></tr>
<tr class="separator:a2ec0c71ef7dc73f371217e33fad9c2ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2cce1e3a95037eecbc511d632127632" id="r_ad2cce1e3a95037eecbc511d632127632"><td class="memItemLeft" align="right" valign="top"><a id="ad2cce1e3a95037eecbc511d632127632" name="ad2cce1e3a95037eecbc511d632127632"></a>
<a class="el" href="structutil_1_1mem_1_1PairPack.html">PairPack</a>&#160;</td><td class="memItemRight" valign="bottom"><b>partial_table</b> [UnionType::Info::COUNT]</td></tr>
<tr class="memdesc:ad2cce1e3a95037eecbc511d632127632"><td class="mdescLeft">&#160;</td><td class="mdescRight">A table used to mediate the coalescing of links. <br /></td></tr>
<tr class="separator:ad2cce1e3a95037eecbc511d632127632"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-static-attribs" name="pub-static-attribs"></a>
Static Public Attributes</h2></td></tr>
<tr class="memitem:a0a654fc4bc103e988832d33ea156e7a2" id="r_a0a654fc4bc103e988832d33ea156e7a2"><td class="memItemLeft" align="right" valign="top">static const size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0a654fc4bc103e988832d33ea156e7a2">TYPE_COUNT</a> = UnionType::Info::COUNT</td></tr>
<tr class="separator:a0a654fc4bc103e988832d33ea156e7a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><div class="compoundTemplParams">template&lt;typename OP_SET, typename ADR_TYPE&gt;<br />
struct RemappingBarrier&lt; OP_SET, ADR_TYPE &gt;</div><p>The <code>RamappingBarrier</code> template struct is a barrier that can store an arbitrary number of promises with any operation type contained by its operation set, automatically coalescing promises of equivalent type into work links.</p>
<p>A <code><a class="el" href="structRemappingBarrier.html">RemappingBarrier</a></code> coaleces promises into links in a lock-free manner. Once released, all work in the queue is made available for work groups to execute and all further appending operations will redirect promises to execution. After being released, a queue may be reset to a non-released state. </p>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a id="ab5d485e3c922cd80d4def4d2db8c7ea8" name="ab5d485e3c922cd80d4def4d2db8c7ea8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab5d485e3c922cd80d4def4d2db8c7ea8">&#9670;&#160;</a></span>add_semaphore()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename OP_SET , typename ADR_TYPE &gt; </div>
<div class="memtemplate">
template&lt;typename PROGRAM &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">__device__ void <a class="el" href="structRemappingBarrier.html">RemappingBarrier</a>&lt; OP_SET, ADR_TYPE &gt;::add_semaphore </td>
          <td>(</td>
          <td class="paramtype">PROGRAM</td>          <td class="paramname"><span class="paramname"><em>program</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int</td>          <td class="paramname"><span class="paramname"><em>delta</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Adds the supplied delta value to the semaphore and performs a release sweep if the result value is zero. </p>

</div>
</div>
<a id="ae19b28f54738fb8d3d52b2afdc36e7d5" name="ae19b28f54738fb8d3d52b2afdc36e7d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae19b28f54738fb8d3d52b2afdc36e7d5">&#9670;&#160;</a></span>await()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename OP_SET , typename ADR_TYPE &gt; </div>
<div class="memtemplate">
template&lt;bool CAN_RELEASE = true, typename PROGRAM , typename OP_TYPE &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">__device__ void <a class="el" href="structRemappingBarrier.html">RemappingBarrier</a>&lt; OP_SET, ADR_TYPE &gt;::await </td>
          <td>(</td>
          <td class="paramtype">PROGRAM</td>          <td class="paramname"><span class="paramname"><em>program</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structPromise.html">Promise</a>&lt; OP_TYPE &gt;</td>          <td class="paramname"><span class="paramname"><em>promise</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Awaits the barrier with th supplied promise. </p>
<p>Guards invocations of the function to make sure invalid promise types are not passed in.</p>
<p>We check the semaphore. If the semaphore is non-zero, the queue has been released, and so the promise can be queued normally. This check does not force a load with atomics (as is done later) because the benefits of a forced load don't seem to make up for the overhead.</p>
<p>We start off with a link containing just our input promise. Depending upon how merges transpire, this link will either fill up and be successfully deposited into the queue, or will have its contents drained into a different link and will be stored away for future use.</p>
<p>Attempt to claim a slot in the link just by incrementing the index of the index/address pair pack. This is quicker, but only works if the incrementation reaches the field before other threads claim the remaining promise slots.</p>
<p>Gain exclusive access to link via an atomic exchange. This is slower, but has guaranteed progress.</p>
<p>Handle cases where represented link is null or already full</p>
<p>Optimistic queuing must retry, but pessimistic queueing can get away with leaving its link behind and doing nothing else.</p>
<p>If the current thread has custody of the destination link, it must handle appending it to the full list if it is full and merging it into the partial slot if it is partial.</p>
<p>Append full destination links to the full list. DO NOT BREAK FROM THE LOOP. There may be a partial source link that still needs to be merged in another pass.</p>
<p>Dump the current spare link and restart the merging procedure with our new partial link</p>
<p>This case should not happen, but it does not hurt to include a branch to handle it, in case something unexpected occurs.</p>
<p>If the spare link is empty, dump it rather than try to merge</p>
<p>Double-check the sememaphore at the end. It is very important we do this double check and that we do it at the very end of every append operation. Because custody of partial links can be given to any append operation of the corresponding operation type, and we don't know which append operation comes last, we need to assume that, if the append has gotten this far, it may be the last append and hence should make sure that no work is left behind.</p>

</div>
</div>
<a id="aabe5bd0015158048475abcfa99274ceb" name="aabe5bd0015158048475abcfa99274ceb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aabe5bd0015158048475abcfa99274ceb">&#9670;&#160;</a></span>blank()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename OP_SET , typename ADR_TYPE &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static __host__ __device__ <a class="el" href="structRemappingBarrier.html">RemappingBarrier</a>&lt; OP_SET, ADR_TYPE &gt; <a class="el" href="structRemappingBarrier.html">RemappingBarrier</a>&lt; OP_SET, ADR_TYPE &gt;::blank </td>
          <td>(</td>
          <td class="paramtype">unsigned int</td>          <td class="paramname"><span class="paramname"><em>sem_val</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Creates a new <code><a class="el" href="structRemappingBarrier.html">RemappingBarrier</a></code> with an empty full queue and partial table and with a semaphore value initialized to the supplied value. </p>

</div>
</div>
<a id="afb589fab108491bf44e319897f29e43b" name="afb589fab108491bf44e319897f29e43b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afb589fab108491bf44e319897f29e43b">&#9670;&#160;</a></span>merge_links()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename OP_SET , typename ADR_TYPE &gt; </div>
<div class="memtemplate">
template&lt;typename PROGRAM &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">__device__ bool <a class="el" href="structRemappingBarrier.html">RemappingBarrier</a>&lt; OP_SET, ADR_TYPE &gt;::merge_links </td>
          <td>(</td>
          <td class="paramtype">PROGRAM</td>          <td class="paramname"><span class="paramname"><em>program</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structutil_1_1mem_1_1PairPack.html">PairPack</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>dst</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structutil_1_1mem_1_1PairPack.html">PairPack</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>src</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>claimed</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Merges data from the link supplied as the third argument into the remaning space available in the link supplied as the second argument. The link given by the third argument must never have any merges in flight with it as the destination. The link given by the second argument may have concurent merges in flight with it as the destination. If the link given by the second argument was claimed from a partial slot through an atomic exchange. If it has been claimed, the fourth argument MUST be true. Likewise, if it has not been claimed, the fourth argument MUST NOT be true. This is done to ensure that, if a link is merged into but is still not full, that link can be safely used in future merging operations as a source.</p>
<p>After merging, the count fields of the input pairs are updated to reflect the change in occupancy. If the current thread is found to have custody of the destination link, this function returns true. Otherwise, false. </p>
<p>If checkout==0, this thread is the last thread to modify the link, and the link has not been marked for dumping. This means we have custody of the link and must manage getting it into the queue via a partial slot or the full list.</p>
<p>If checkout==(GROUP_SIZE+1), this thread is the last thread to modify the link, and the link has been marked for dumping. This means we have custody of the link and must release it.</p>
<p>In all other cases, we have no custody of the link.</p>

</div>
</div>
<a id="ad434c872cdbe5c42bedbe19ff81564b1" name="ad434c872cdbe5c42bedbe19ff81564b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad434c872cdbe5c42bedbe19ff81564b1">&#9670;&#160;</a></span>release()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename OP_SET , typename ADR_TYPE &gt; </div>
<div class="memtemplate">
template&lt;typename PROGRAM &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">__device__ void <a class="el" href="structRemappingBarrier.html">RemappingBarrier</a>&lt; OP_SET, ADR_TYPE &gt;::release </td>
          <td>(</td>
          <td class="paramtype">PROGRAM</td>          <td class="paramname"><span class="paramname"><em>program</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Sets the semaphore to zero and performs a release sweep. The sweep is necessary, because it is possible for no append operations to occur after a release operation. </p>

</div>
</div>
<a id="a377e0b11a8034b1f48b10abc71d44fb4" name="a377e0b11a8034b1f48b10abc71d44fb4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a377e0b11a8034b1f48b10abc71d44fb4">&#9670;&#160;</a></span>release_partial()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename OP_SET , typename ADR_TYPE &gt; </div>
<div class="memtemplate">
template&lt;typename PROGRAM &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">__device__ void <a class="el" href="structRemappingBarrier.html">RemappingBarrier</a>&lt; OP_SET, ADR_TYPE &gt;::release_partial </td>
          <td>(</td>
          <td class="paramtype">PROGRAM</td>          <td class="paramname"><span class="paramname"><em>program</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structutil_1_1mem_1_1PairPack.html">PairPack</a></td>          <td class="paramname"><span class="paramname"><em>pair</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This does not truely release partial links, but will mark the link for dumping by bumping the next semaphore by the index of the claimed pair plus 1. This means that, after all true promise insertions have occured, the next semaphore will be at GROUP_SIZE+1, a normally impossible value. Should the semaphore reach GROUP_SIZE+1 directly after the incrementation (and should the semaphore not have an original value of zero), this call will truely release the link. This caveat to zero-valued initial values prevents double-queuing. </p>

</div>
</div>
<a id="adc9aa106be170426eea8edb394dcb0fe" name="adc9aa106be170426eea8edb394dcb0fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adc9aa106be170426eea8edb394dcb0fe">&#9670;&#160;</a></span>release_sweep()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename OP_SET , typename ADR_TYPE &gt; </div>
<div class="memtemplate">
template&lt;typename PROGRAM &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">__device__ void <a class="el" href="structRemappingBarrier.html">RemappingBarrier</a>&lt; OP_SET, ADR_TYPE &gt;::release_sweep </td>
          <td>(</td>
          <td class="paramtype">PROGRAM</td>          <td class="paramname"><span class="paramname"><em>program</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Sweeps through full list and partial slots, releasing any queues or links that is found in the sweep. </p>

</div>
</div>
<a id="a77c9173db860ba0b33c4ef71647d4b3a" name="a77c9173db860ba0b33c4ef71647d4b3a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a77c9173db860ba0b33c4ef71647d4b3a">&#9670;&#160;</a></span>sub_semaphore()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename OP_SET , typename ADR_TYPE &gt; </div>
<div class="memtemplate">
template&lt;typename PROGRAM &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">__device__ void <a class="el" href="structRemappingBarrier.html">RemappingBarrier</a>&lt; OP_SET, ADR_TYPE &gt;::sub_semaphore </td>
          <td>(</td>
          <td class="paramtype">PROGRAM</td>          <td class="paramname"><span class="paramname"><em>program</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int</td>          <td class="paramname"><span class="paramname"><em>delta</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Subtracts the supplied delta value from the semaphore and performs a release sweep if the result value is zero. </p>

</div>
</div>
<a id="a5c75f081a27904e358216e47dc1840f7" name="a5c75f081a27904e358216e47dc1840f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5c75f081a27904e358216e47dc1840f7">&#9670;&#160;</a></span>union_await()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename OP_SET , typename ADR_TYPE &gt; </div>
<div class="memtemplate">
template&lt;bool CAN_RELEASE = true, typename PROGRAM &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">__device__ void <a class="el" href="structRemappingBarrier.html">RemappingBarrier</a>&lt; OP_SET, ADR_TYPE &gt;::union_await </td>
          <td>(</td>
          <td class="paramtype">PROGRAM</td>          <td class="paramname"><span class="paramname"><em>program</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OpDisc</td>          <td class="paramname"><span class="paramname"><em>disc</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename PROGRAM::PromiseUnionType</td>          <td class="paramname"><span class="paramname"><em>promise_union</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Awaits the barrier with a promise union, using the provided discriminant to determine the type of the contained promise. </p>
<p>We check the semaphore. If the semaphore is non-zero, the queue has been released, and so the promise can be queued normally. This check does not force a load with atomics (as is done later) because the benefits of a forced load don't seem to make up for the overhead.</p>
<p>We start off with a link containing just our input promise. Depending upon how merges transpire, this link will either fill up and be successfully deposited into the queue, or will have its contents drained into a different link and will be stored away for future use.</p>
<p>Attempt to claim a slot in the link just by incrementing the index of the index/address pair pack. This is quicker, but only works if the incrementation reaches the field before other threads claim the remaining promise slots.</p>
<p>Gain exclusive access to link via an atomic exchange. This is slower, but has guaranteed progress.</p>
<p>Handle cases where represented link is null or already full</p>
<p>Optimistic queuing must retry, but pessimistic queueing can get away with leaving its link behind and doing nothing else.</p>
<p>If the current thread has custody of the destination link, it must handle appending it to the full list if it is full and merging it into the partial slot if it is partial.</p>
<p>Append full destination links to the full list. DO NOT BREAK FROM THE LOOP. There may be a partial source link that still needs to be merged in another pass.</p>
<p>Dump the current spare link and restart the merging procedure with our new partial link</p>
<p>This case should not happen, but it does not hurt to include a branch to handle it, in case something unexpected occurs.</p>
<p>If the spare link is empty, dump it rather than try to merge</p>
<p>Double-check the sememaphore at the end. It is very important we do this double check and that we do it at the very end of every append operation. Because custody of partial links can be given to any append operation of the corresponding operation type, and we don't know which append operation comes last, we need to assume that, if the append has gotten this far, it may be the last append and hence should make sure that no work is left behind.</p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a2ec0c71ef7dc73f371217e33fad9c2ad" name="a2ec0c71ef7dc73f371217e33fad9c2ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2ec0c71ef7dc73f371217e33fad9c2ad">&#9670;&#160;</a></span>full_list</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename OP_SET , typename ADR_TYPE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structutil_1_1mem_1_1PoolQueue.html">QueueType</a> <a class="el" href="structRemappingBarrier.html">RemappingBarrier</a>&lt; OP_SET, ADR_TYPE &gt;::full_list</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>A queue that contains all full links created by coalescing promises awaiting the release of the barrier. </p>

</div>
</div>
<a id="ad944fdab30123caa204607596a3e784e" name="ad944fdab30123caa204607596a3e784e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad944fdab30123caa204607596a3e784e">&#9670;&#160;</a></span>semaphore</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename OP_SET , typename ADR_TYPE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structTaggedSemaphore.html">TaggedSemaphore</a> <a class="el" href="structRemappingBarrier.html">RemappingBarrier</a>&lt; OP_SET, ADR_TYPE &gt;::semaphore</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>A tagged semaphore that communicates both the release state of the barrier, but the type of the barrier as well. </p>

</div>
</div>
<a id="a0a654fc4bc103e988832d33ea156e7a2" name="a0a654fc4bc103e988832d33ea156e7a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0a654fc4bc103e988832d33ea156e7a2">&#9670;&#160;</a></span>TYPE_COUNT</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename OP_SET , typename ADR_TYPE &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const size_t <a class="el" href="structRemappingBarrier.html">RemappingBarrier</a>&lt; OP_SET, ADR_TYPE &gt;::TYPE_COUNT = UnionType::Info::COUNT</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The number of operations contained within the barrier's operation set. </p>

</div>
</div>
<hr/>The documentation for this struct was generated from the following files:<ul>
<li>harmonize/cpp/async/<a class="el" href="promise_8h_source.html">promise.h</a></li>
<li>harmonize/cpp/sync/<a class="el" href="barrier_8h_source.html">barrier.h</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="structRemappingBarrier.html">RemappingBarrier</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.12.0 </li>
  </ul>
</div>
</body>
</html>
