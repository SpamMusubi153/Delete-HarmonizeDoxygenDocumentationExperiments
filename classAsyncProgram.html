<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.12.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Harmonize: AsyncProgram&lt; PROGRAM_SPEC &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Harmonize
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.12.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search',true);
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('classAsyncProgram.html',''); initResizable(true); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pub-attribs">Public Attributes</a> &#124;
<a href="#pub-static-attribs">Static Public Attributes</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="classAsyncProgram-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">AsyncProgram&lt; PROGRAM_SPEC &gt; Class Template Reference</div></div>
</div><!--header-->
<div class="contents">

<p>The class that defines an asynchronous program and all of its types.  
 <a href="#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="async_8h_source.html">async.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structAsyncProgram_1_1DeviceContext.html">DeviceContext</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structAsyncProgram_1_1GroupContext.html">GroupContext</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structAsyncProgram_1_1Instance.html">Instance</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structAsyncProgram_1_1Lookup.html">Lookup</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Used to look up information about the primary <code><a class="el" href="unionPromiseUnion.html">PromiseUnion</a></code> type used.  <a href="structAsyncProgram_1_1Lookup.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structAsyncProgram_1_1RemapQueue.html">RemapQueue</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structAsyncProgram_1_1Specializer.html">Specializer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Templates for use by <code>TEMPLATE_MEMBER_SWITCH</code>  <a href="structAsyncProgram_1_1Specializer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structAsyncProgram_1_1Specializer_3_01BASE_3_01ProgramType_01_4_01_4.html">Specializer&lt; BASE&lt; ProgramType &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structAsyncProgram_1_1ThreadContext.html">ThreadContext</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-types" name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:ad9534061fd30bd6b3419acfb8368de6a" id="r_ad9534061fd30bd6b3419acfb8368de6a"><td class="memItemLeft" align="right" valign="top"><a id="ad9534061fd30bd6b3419acfb8368de6a" name="ad9534061fd30bd6b3419acfb8368de6a"></a>
typedef <a class="el" href="classAsyncProgram.html">AsyncProgram</a>&lt; PROGRAM_SPEC &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>ProgramType</b></td></tr>
<tr class="separator:ad9534061fd30bd6b3419acfb8368de6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad87689d084dfa71a790291153a1192ee" id="r_ad87689d084dfa71a790291153a1192ee"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="unionPromiseUnion.html">PromiseUnion</a>&lt; OpSet &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad87689d084dfa71a790291153a1192ee">PromiseUnionType</a></td></tr>
<tr class="memdesc:ad87689d084dfa71a790291153a1192ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Define the states stored in global, shared, and private memory.  <br /></td></tr>
<tr class="separator:ad87689d084dfa71a790291153a1192ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c9098c42fa96932d28d5d0f1821a383" id="r_a6c9098c42fa96932d28d5d0f1821a383"><td class="memItemLeft" align="right" valign="top"><a id="a6c9098c42fa96932d28d5d0f1821a383" name="a6c9098c42fa96932d28d5d0f1821a383"></a>
typedef <a class="el" href="structutil_1_1mem_1_1Adr.html">util::mem::Adr</a>&lt; AdrType &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>LinkAdrType</b></td></tr>
<tr class="memdesc:a6c9098c42fa96932d28d5d0f1821a383"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defining a set of internal short-hand names for the specializaions used by the class. <br /></td></tr>
<tr class="separator:a6c9098c42fa96932d28d5d0f1821a383"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a772a3d79328cbae936a99b6c81048365" id="r_a772a3d79328cbae936a99b6c81048365"><td class="memItemLeft" align="right" valign="top"><a id="a772a3d79328cbae936a99b6c81048365" name="a772a3d79328cbae936a99b6c81048365"></a>
typedef <a class="el" href="structutil_1_1mem_1_1PoolQueue.html">util::mem::PoolQueue</a>&lt; <a class="el" href="#a6c9098c42fa96932d28d5d0f1821a383">LinkAdrType</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>QueueType</b></td></tr>
<tr class="separator:a772a3d79328cbae936a99b6c81048365"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e968d2ddab57660b2db29a699bd4047" id="r_a6e968d2ddab57660b2db29a699bd4047"><td class="memItemLeft" align="right" valign="top"><a id="a6e968d2ddab57660b2db29a699bd4047" name="a6e968d2ddab57660b2db29a699bd4047"></a>
typedef <a class="el" href="structWorkFrame.html">WorkFrame</a>&lt; <a class="el" href="structutil_1_1mem_1_1PoolQueue.html">QueueType</a>, FRAME_SIZE &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>FrameType</b></td></tr>
<tr class="separator:a6e968d2ddab57660b2db29a699bd4047"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a23261045b1bf9eba29c9748bc5404d" id="r_a3a23261045b1bf9eba29c9748bc5404d"><td class="memItemLeft" align="right" valign="top"><a id="a3a23261045b1bf9eba29c9748bc5404d" name="a3a23261045b1bf9eba29c9748bc5404d"></a>
typedef <a class="el" href="structWorkStack.html">WorkStack</a>&lt; <a class="el" href="structWorkFrame.html">FrameType</a>, STACK_SIZE &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>StackType</b></td></tr>
<tr class="separator:a3a23261045b1bf9eba29c9748bc5404d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04803147ec0699c9ff0ad8580e97bff5" id="r_a04803147ec0699c9ff0ad8580e97bff5"><td class="memItemLeft" align="right" valign="top"><a id="a04803147ec0699c9ff0ad8580e97bff5" name="a04803147ec0699c9ff0ad8580e97bff5"></a>
typedef <a class="el" href="structWorkPool.html">WorkPool</a>&lt; <a class="el" href="structutil_1_1mem_1_1PoolQueue.html">QueueType</a>, POOL_SIZE &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>PoolType</b></td></tr>
<tr class="separator:a04803147ec0699c9ff0ad8580e97bff5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2be150315d842a05e3315918e3f412c" id="r_ad2be150315d842a05e3315918e3f412c"><td class="memItemLeft" align="right" valign="top"><a id="ad2be150315d842a05e3315918e3f412c" name="ad2be150315d842a05e3315918e3f412c"></a>
typedef <a class="el" href="structWorkLink.html">WorkLink</a>&lt; OpSet, <a class="el" href="#a6c9098c42fa96932d28d5d0f1821a383">LinkAdrType</a>, WORK_GROUP_SIZE &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>LinkType</b></td></tr>
<tr class="separator:ad2be150315d842a05e3315918e3f412c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2579dc279e4673606047d78156e1a53b" id="r_a2579dc279e4673606047d78156e1a53b"><td class="memItemLeft" align="right" valign="top"><a id="a2579dc279e4673606047d78156e1a53b" name="a2579dc279e4673606047d78156e1a53b"></a>
typedef <a class="el" href="structWorkArena.html">WorkArena</a>&lt; <a class="el" href="#a6c9098c42fa96932d28d5d0f1821a383">LinkAdrType</a>, <a class="el" href="structWorkLink.html">LinkType</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>ArenaType</b></td></tr>
<tr class="separator:a2579dc279e4673606047d78156e1a53b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:aa22b2949373480a0dab473f2eb8e28b8" id="r_aa22b2949373480a0dab473f2eb8e28b8"><td class="memItemLeft" align="right" valign="top"><a id="aa22b2949373480a0dab473f2eb8e28b8" name="aa22b2949373480a0dab473f2eb8e28b8"></a>
__device__&#160;</td><td class="memItemRight" valign="bottom"><b>AsyncProgram</b> (<a class="el" href="structAsyncProgram_1_1DeviceContext.html">DeviceContext</a> &amp;d_c, <a class="el" href="structAsyncProgram_1_1GroupContext.html">GroupContext</a> &amp;g_c, <a class="el" href="structAsyncProgram_1_1ThreadContext.html">ThreadContext</a> &amp;t_c, DeviceState &amp;d, GroupState &amp;g, ThreadState &amp;t)</td></tr>
<tr class="separator:aa22b2949373480a0dab473f2eb8e28b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d3ddf8da53f0cb7b7816a14683ad2b3" id="r_a9d3ddf8da53f0cb7b7816a14683ad2b3"><td class="memItemLeft" align="right" valign="top"><a id="a9d3ddf8da53f0cb7b7816a14683ad2b3" name="a9d3ddf8da53f0cb7b7816a14683ad2b3"></a>
__device__ void&#160;</td><td class="memItemRight" valign="bottom"><b>init_program</b> ()</td></tr>
<tr class="separator:a9d3ddf8da53f0cb7b7816a14683ad2b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9ab96e52afba26893168ce9bc70af57" id="r_af9ab96e52afba26893168ce9bc70af57"><td class="memItemLeft" align="right" valign="top"><a id="af9ab96e52afba26893168ce9bc70af57" name="af9ab96e52afba26893168ce9bc70af57"></a>
__device__ void&#160;</td><td class="memItemRight" valign="bottom"><b>push_calls</b> (<a class="el" href="structAsyncProgram_1_1DeviceContext.html">DeviceContext</a> _dev_ctx, <a class="el" href="structWorkLink.html">LinkType</a> *call_buffer, size_t link_count)</td></tr>
<tr class="separator:af9ab96e52afba26893168ce9bc70af57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac81209d572b5051ab8750364efaeb85e" id="r_ac81209d572b5051ab8750364efaeb85e"><td class="memItemLeft" align="right" valign="top"><a id="ac81209d572b5051ab8750364efaeb85e" name="ac81209d572b5051ab8750364efaeb85e"></a>
__device__ void&#160;</td><td class="memItemRight" valign="bottom"><b>pull_promises</b> (<a class="el" href="structAsyncProgram_1_1Instance.html">Instance</a> &amp;instance)</td></tr>
<tr class="separator:ac81209d572b5051ab8750364efaeb85e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6b88bc9ac6fbf28d67567efc4a8d855" id="r_af6b88bc9ac6fbf28d67567efc4a8d855"><td class="memItemLeft" align="right" valign="top"><a id="af6b88bc9ac6fbf28d67567efc4a8d855" name="af6b88bc9ac6fbf28d67567efc4a8d855"></a>
__device__ void&#160;</td><td class="memItemRight" valign="bottom"><b>exec</b> (unsigned int cycle_count)</td></tr>
<tr class="separator:af6b88bc9ac6fbf28d67567efc4a8d855"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a500c119a135bdcc8b83b24e58425e752" id="r_a500c119a135bdcc8b83b24e58425e752"><td class="memTemplParams" colspan="2"><a id="a500c119a135bdcc8b83b24e58425e752" name="a500c119a135bdcc8b83b24e58425e752"></a>
template&lt;typename TYPE , typename... ARGS&gt; </td></tr>
<tr class="memitem:a500c119a135bdcc8b83b24e58425e752"><td class="memTemplItemLeft" align="right" valign="top">__device__ void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>async</b> (ARGS... args)</td></tr>
<tr class="separator:a500c119a135bdcc8b83b24e58425e752"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1cf4231a510308f65c42db45d0f7d6c" id="r_ae1cf4231a510308f65c42db45d0f7d6c"><td class="memTemplParams" colspan="2"><a id="ae1cf4231a510308f65c42db45d0f7d6c" name="ae1cf4231a510308f65c42db45d0f7d6c"></a>
template&lt;typename TYPE , typename... ARGS&gt; </td></tr>
<tr class="memitem:ae1cf4231a510308f65c42db45d0f7d6c"><td class="memTemplItemLeft" align="right" valign="top">__device__ void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>sync</b> (ARGS... args)</td></tr>
<tr class="separator:ae1cf4231a510308f65c42db45d0f7d6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f38fb2fcdf7affb8c6250621a6c77e5" id="r_a1f38fb2fcdf7affb8c6250621a6c77e5"><td class="memTemplParams" colspan="2"><a id="a1f38fb2fcdf7affb8c6250621a6c77e5" name="a1f38fb2fcdf7affb8c6250621a6c77e5"></a>
template&lt;typename TYPE &gt; </td></tr>
<tr class="memitem:a1f38fb2fcdf7affb8c6250621a6c77e5"><td class="memTemplItemLeft" align="right" valign="top">__device__ float&#160;</td><td class="memTemplItemRight" valign="bottom"><b>load_fraction</b> ()</td></tr>
<tr class="separator:a1f38fb2fcdf7affb8c6250621a6c77e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c940f1974ab7cfb8942bf26b574988d" id="r_a8c940f1974ab7cfb8942bf26b574988d"><td class="memItemLeft" align="right" valign="top"><a id="a8c940f1974ab7cfb8942bf26b574988d" name="a8c940f1974ab7cfb8942bf26b574988d"></a>
__device__ void&#160;</td><td class="memItemRight" valign="bottom"><b>halt_early</b> ()</td></tr>
<tr class="separator:a8c940f1974ab7cfb8942bf26b574988d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-static-methods" name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:acd87778d90d33b95246557e7a076721c" id="r_acd87778d90d33b95246557e7a076721c"><td class="memItemLeft" align="right" valign="top"><a id="acd87778d90d33b95246557e7a076721c" name="acd87778d90d33b95246557e7a076721c"></a>
static void&#160;</td><td class="memItemRight" valign="bottom"><b>check_error</b> ()</td></tr>
<tr class="separator:acd87778d90d33b95246557e7a076721c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b884d1d1c25e2c66e15759fe3c546b2" id="r_a2b884d1d1c25e2c66e15759fe3c546b2"><td class="memItemLeft" align="right" valign="top"><a id="a2b884d1d1c25e2c66e15759fe3c546b2" name="a2b884d1d1c25e2c66e15759fe3c546b2"></a>
static __host__ bool&#160;</td><td class="memItemRight" valign="bottom"><b>queue_count</b> (<a class="el" href="structAsyncProgram_1_1Instance.html">Instance</a> runtime, <a class="el" href="structWorkLink.html">LinkType</a> *host_arena, <a class="el" href="structutil_1_1mem_1_1PoolQueue.html">QueueType</a> queue, <a class="el" href="#a6c9098c42fa96932d28d5d0f1821a383">LinkAdrType</a> &amp;result)</td></tr>
<tr class="separator:a2b884d1d1c25e2c66e15759fe3c546b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76bdcc675a8c755006133be5ee163053" id="r_a76bdcc675a8c755006133be5ee163053"><td class="memItemLeft" align="right" valign="top"><a id="a76bdcc675a8c755006133be5ee163053" name="a76bdcc675a8c755006133be5ee163053"></a>
static __host__ bool&#160;</td><td class="memItemRight" valign="bottom"><b>runtime_overview</b> (<a class="el" href="structAsyncProgram_1_1Instance.html">Instance</a> runtime)</td></tr>
<tr class="separator:a76bdcc675a8c755006133be5ee163053"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-attribs" name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr class="memitem:aee9c298ce109da1be451d3bb82453025" id="r_aee9c298ce109da1be451d3bb82453025"><td class="memItemLeft" align="right" valign="top"><a id="aee9c298ce109da1be451d3bb82453025" name="aee9c298ce109da1be451d3bb82453025"></a>
<a class="el" href="structAsyncProgram_1_1DeviceContext.html">DeviceContext</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>_dev_ctx</b></td></tr>
<tr class="separator:aee9c298ce109da1be451d3bb82453025"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a474c1e981b0ba8964349a9c275d0a054" id="r_a474c1e981b0ba8964349a9c275d0a054"><td class="memItemLeft" align="right" valign="top"><a id="a474c1e981b0ba8964349a9c275d0a054" name="a474c1e981b0ba8964349a9c275d0a054"></a>
<a class="el" href="structAsyncProgram_1_1GroupContext.html">GroupContext</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>_grp_ctx</b></td></tr>
<tr class="separator:a474c1e981b0ba8964349a9c275d0a054"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af63fb8ee7c6ae5bcbfe4577f7034e36b" id="r_af63fb8ee7c6ae5bcbfe4577f7034e36b"><td class="memItemLeft" align="right" valign="top"><a id="af63fb8ee7c6ae5bcbfe4577f7034e36b" name="af63fb8ee7c6ae5bcbfe4577f7034e36b"></a>
<a class="el" href="structAsyncProgram_1_1ThreadContext.html">ThreadContext</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>_thd_ctx</b></td></tr>
<tr class="separator:af63fb8ee7c6ae5bcbfe4577f7034e36b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1efe5985cecd6ca3a5428af9f623bd1" id="r_ab1efe5985cecd6ca3a5428af9f623bd1"><td class="memItemLeft" align="right" valign="top"><a id="ab1efe5985cecd6ca3a5428af9f623bd1" name="ab1efe5985cecd6ca3a5428af9f623bd1"></a>
DeviceState &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>device</b></td></tr>
<tr class="separator:ab1efe5985cecd6ca3a5428af9f623bd1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abdb2e43a99a0eb3b47ac6370ea4ed0c8" id="r_abdb2e43a99a0eb3b47ac6370ea4ed0c8"><td class="memItemLeft" align="right" valign="top"><a id="abdb2e43a99a0eb3b47ac6370ea4ed0c8" name="abdb2e43a99a0eb3b47ac6370ea4ed0c8"></a>
GroupState &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>group</b></td></tr>
<tr class="separator:abdb2e43a99a0eb3b47ac6370ea4ed0c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afbc445ce635a82b657b65806613ca2b3" id="r_afbc445ce635a82b657b65806613ca2b3"><td class="memItemLeft" align="right" valign="top"><a id="afbc445ce635a82b657b65806613ca2b3" name="afbc445ce635a82b657b65806613ca2b3"></a>
ThreadState &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>thread</b></td></tr>
<tr class="separator:afbc445ce635a82b657b65806613ca2b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-static-attribs" name="pub-static-attribs"></a>
Static Public Attributes</h2></td></tr>
<tr class="memitem:acacc3e33ace53657a282efe324d6fe5f" id="r_acacc3e33ace53657a282efe324d6fe5f"><td class="memItemLeft" align="right" valign="top">static const size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#acacc3e33ace53657a282efe324d6fe5f">STASH_MARGIN</a> = 2</td></tr>
<tr class="separator:acacc3e33ace53657a282efe324d6fe5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7bf13749d69340188604b45642eaf681" id="r_a7bf13749d69340188604b45642eaf681"><td class="memItemLeft" align="right" valign="top"><a id="a7bf13749d69340188604b45642eaf681" name="a7bf13749d69340188604b45642eaf681"></a>
static const size_t&#160;</td><td class="memItemRight" valign="bottom"><b>STASH_HIGH_WATER</b> = STASH_SIZE-<a class="el" href="#acacc3e33ace53657a282efe324d6fe5f">STASH_MARGIN</a></td></tr>
<tr class="separator:a7bf13749d69340188604b45642eaf681"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ea278f02a1f2115842437bc7a54f0ca" id="r_a5ea278f02a1f2115842437bc7a54f0ca"><td class="memItemLeft" align="right" valign="top"><a id="a5ea278f02a1f2115842437bc7a54f0ca" name="a5ea278f02a1f2115842437bc7a54f0ca"></a>
static const unsigned char&#160;</td><td class="memItemRight" valign="bottom"><b>FN_ID_COUNT</b> = PromiseUnionType::Info::COUNT</td></tr>
<tr class="memdesc:a5ea278f02a1f2115842437bc7a54f0ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">The number of async functions present in the program. <br /></td></tr>
<tr class="separator:a5ea278f02a1f2115842437bc7a54f0ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f1b32e36f3b762455b1ba955ed026fb" id="r_a5f1b32e36f3b762455b1ba955ed026fb"><td class="memItemLeft" align="right" valign="top">static const unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5f1b32e36f3b762455b1ba955ed026fb">PUSH_QUEUE_RETRY_LIMIT</a> = 32</td></tr>
<tr class="separator:a5f1b32e36f3b762455b1ba955ed026fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63868cdce045d5d4f3cb921bc81caf8d" id="r_a63868cdce045d5d4f3cb921bc81caf8d"><td class="memItemLeft" align="right" valign="top"><a id="a63868cdce045d5d4f3cb921bc81caf8d" name="a63868cdce045d5d4f3cb921bc81caf8d"></a>
static const unsigned int&#160;</td><td class="memItemRight" valign="bottom"><b>FILL_STASH_RETRY_LIMIT</b> = 1</td></tr>
<tr class="separator:a63868cdce045d5d4f3cb921bc81caf8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a57d97c2e9f3bd182a275c5ded78ffa" id="r_a0a57d97c2e9f3bd182a275c5ded78ffa"><td class="memItemLeft" align="right" valign="top"><a id="a0a57d97c2e9f3bd182a275c5ded78ffa" name="a0a57d97c2e9f3bd182a275c5ded78ffa"></a>
static const unsigned int&#160;</td><td class="memItemRight" valign="bottom"><b>FILL_STASH_LINKS_RETRY_LIMIT</b> = 32</td></tr>
<tr class="separator:a0a57d97c2e9f3bd182a275c5ded78ffa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a55d96146e15e87bc5bc2d8047dbe4c" id="r_a5a55d96146e15e87bc5bc2d8047dbe4c"><td class="memItemLeft" align="right" valign="top"><a id="a5a55d96146e15e87bc5bc2d8047dbe4c" name="a5a55d96146e15e87bc5bc2d8047dbe4c"></a>
static const size_t&#160;</td><td class="memItemRight" valign="bottom"><b>WORK_GROUP_SIZE</b> = GROUP_SIZE</td></tr>
<tr class="separator:a5a55d96146e15e87bc5bc2d8047dbe4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c01a98194c5ffc4e1698be186b9c7cd" id="r_a7c01a98194c5ffc4e1698be186b9c7cd"><td class="memItemLeft" align="right" valign="top"><a id="a7c01a98194c5ffc4e1698be186b9c7cd" name="a7c01a98194c5ffc4e1698be186b9c7cd"></a>
static const unsigned int&#160;</td><td class="memItemRight" valign="bottom"><b>BAD_FUNC_ID_FLAG</b> = 0x00000001</td></tr>
<tr class="memdesc:a7c01a98194c5ffc4e1698be186b9c7cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">A set of halting condition flags. <br /></td></tr>
<tr class="separator:a7c01a98194c5ffc4e1698be186b9c7cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a970b79ac9c93226e95fdad4e4076ed2f" id="r_a970b79ac9c93226e95fdad4e4076ed2f"><td class="memItemLeft" align="right" valign="top"><a id="a970b79ac9c93226e95fdad4e4076ed2f" name="a970b79ac9c93226e95fdad4e4076ed2f"></a>
static const unsigned int&#160;</td><td class="memItemRight" valign="bottom"><b>STASH_FAIL_FLAG</b> = 0x00000002</td></tr>
<tr class="separator:a970b79ac9c93226e95fdad4e4076ed2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7c0efa2c6d40d68af85f22bc23bff55" id="r_ab7c0efa2c6d40d68af85f22bc23bff55"><td class="memItemLeft" align="right" valign="top"><a id="ab7c0efa2c6d40d68af85f22bc23bff55" name="ab7c0efa2c6d40d68af85f22bc23bff55"></a>
static const unsigned int&#160;</td><td class="memItemRight" valign="bottom"><b>COMPLETION_FLAG</b> = 0x80000000</td></tr>
<tr class="separator:ab7c0efa2c6d40d68af85f22bc23bff55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3415a0c331d39aa160da91514607f12" id="r_af3415a0c331d39aa160da91514607f12"><td class="memItemLeft" align="right" valign="top"><a id="af3415a0c331d39aa160da91514607f12" name="af3415a0c331d39aa160da91514607f12"></a>
static const unsigned int&#160;</td><td class="memItemRight" valign="bottom"><b>EARLY_HALT_FLAG</b> = 0x40000000</td></tr>
<tr class="separator:af3415a0c331d39aa160da91514607f12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d9ed9b669227665894c3519b5db4aa3" id="r_a5d9ed9b669227665894c3519b5db4aa3"><td class="memItemLeft" align="right" valign="top"><a id="a5d9ed9b669227665894c3519b5db4aa3" name="a5d9ed9b669227665894c3519b5db4aa3"></a>
static const unsigned char&#160;</td><td class="memItemRight" valign="bottom"><b>PART_TABLE_DEPTH</b> = StackType::PART_MULT</td></tr>
<tr class="memdesc:a5d9ed9b669227665894c3519b5db4aa3"><td class="mdescLeft">&#160;</td><td class="mdescRight">The depth of the partial table (1 if stack is flat, 3 otherwise). <br /></td></tr>
<tr class="separator:a5d9ed9b669227665894c3519b5db4aa3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6879e9761f8ad3c49ed9e29c7735f3de" id="r_a6879e9761f8ad3c49ed9e29c7735f3de"><td class="memItemLeft" align="right" valign="top"><a id="a6879e9761f8ad3c49ed9e29c7735f3de" name="a6879e9761f8ad3c49ed9e29c7735f3de"></a>
static const unsigned char&#160;</td><td class="memItemRight" valign="bottom"><b>PART_ENTRY_COUNT</b> = <a class="el" href="#a5ea278f02a1f2115842437bc7a54f0ca">FN_ID_COUNT</a>*<a class="el" href="#a5d9ed9b669227665894c3519b5db4aa3">PART_TABLE_DEPTH</a></td></tr>
<tr class="separator:a6879e9761f8ad3c49ed9e29c7735f3de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98d8f12709da7a0b3be8005efd8482c6" id="r_a98d8f12709da7a0b3be8005efd8482c6"><td class="memItemLeft" align="right" valign="top"><a id="a98d8f12709da7a0b3be8005efd8482c6" name="a98d8f12709da7a0b3be8005efd8482c6"></a>
static const AdrType&#160;</td><td class="memItemRight" valign="bottom"><b>SPARE_LINK_COUNT</b> = 2u</td></tr>
<tr class="separator:a98d8f12709da7a0b3be8005efd8482c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pro-methods" name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a12e9df169f450b3514b57569290fa601" id="r_a12e9df169f450b3514b57569290fa601"><td class="memItemLeft" align="right" valign="top"><a id="a12e9df169f450b3514b57569290fa601" name="a12e9df169f450b3514b57569290fa601"></a>
__device__ bool&#160;</td><td class="memItemRight" valign="bottom"><b>stash_overfilled</b> ()</td></tr>
<tr class="memdesc:a12e9df169f450b3514b57569290fa601"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true only if the stash cannot support the allocation of any more work links. <br /></td></tr>
<tr class="separator:a12e9df169f450b3514b57569290fa601"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a017c798fcb9de528856ae3f2b8554122" id="r_a017c798fcb9de528856ae3f2b8554122"><td class="memItemLeft" align="right" valign="top">__device__ unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a017c798fcb9de528856ae3f2b8554122">partial_map_index</a> (OpDisc func_id, unsigned int depth, unsigned int current_level)</td></tr>
<tr class="separator:a017c798fcb9de528856ae3f2b8554122"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93cae7f0050d7a20eace3bb0a9593c19" id="r_a93cae7f0050d7a20eace3bb0a9593c19"><td class="memItemLeft" align="right" valign="top">__device__ void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a93cae7f0050d7a20eace3bb0a9593c19">init_group</a> ()</td></tr>
<tr class="separator:a93cae7f0050d7a20eace3bb0a9593c19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74f486fe485fe183c65337e85d44b52d" id="r_a74f486fe485fe183c65337e85d44b52d"><td class="memItemLeft" align="right" valign="top">__device__ void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a74f486fe485fe183c65337e85d44b52d">init_thread</a> ()</td></tr>
<tr class="separator:a74f486fe485fe183c65337e85d44b52d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a16dacf29b0f5d69911aef18ebdfd00" id="r_a5a16dacf29b0f5d69911aef18ebdfd00"><td class="memItemLeft" align="right" valign="top"><a id="a5a16dacf29b0f5d69911aef18ebdfd00" name="a5a16dacf29b0f5d69911aef18ebdfd00"></a>
__device__ void&#160;</td><td class="memItemRight" valign="bottom"><b>set_flags</b> (unsigned int flag_bits)</td></tr>
<tr class="memdesc:a5a16dacf29b0f5d69911aef18ebdfd00"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the bits in the status_flags field of the stack according to the given flag bits. <br /></td></tr>
<tr class="separator:a5a16dacf29b0f5d69911aef18ebdfd00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae97ef0bf5ad9dc9699f3076f5acef569" id="r_ae97ef0bf5ad9dc9699f3076f5acef569"><td class="memItemLeft" align="right" valign="top"><a id="ae97ef0bf5ad9dc9699f3076f5acef569" name="ae97ef0bf5ad9dc9699f3076f5acef569"></a>
__device__ void&#160;</td><td class="memItemRight" valign="bottom"><b>unset_flags</b> (unsigned int flag_bits)</td></tr>
<tr class="memdesc:ae97ef0bf5ad9dc9699f3076f5acef569"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unsets the bits in the status_flags field of the stack according to the given flag bits. <br /></td></tr>
<tr class="separator:ae97ef0bf5ad9dc9699f3076f5acef569"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a935f3320a31e95f2008254702cabb0ca" id="r_a935f3320a31e95f2008254702cabb0ca"><td class="memItemLeft" align="right" valign="top">__device__ unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a935f3320a31e95f2008254702cabb0ca">highest_level</a> ()</td></tr>
<tr class="separator:a935f3320a31e95f2008254702cabb0ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a711a213bf7a3cced339f41921c66138a" id="r_a711a213bf7a3cced339f41921c66138a"><td class="memItemLeft" align="right" valign="top"><a id="a711a213bf7a3cced339f41921c66138a" name="a711a213bf7a3cced339f41921c66138a"></a>
__device__ <a class="el" href="structWorkFrame.html">FrameType</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>get_frame</b> (unsigned int level)</td></tr>
<tr class="memdesc:a711a213bf7a3cced339f41921c66138a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reference to the frame at the requested level in the stack. <br /></td></tr>
<tr class="separator:a711a213bf7a3cced339f41921c66138a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89530a81b85f94a42dc99b074c9cdd5c" id="r_a89530a81b85f94a42dc99b074c9cdd5c"><td class="memItemLeft" align="right" valign="top">__device__ <a class="el" href="structutil_1_1mem_1_1PoolQueue.html">QueueType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a89530a81b85f94a42dc99b074c9cdd5c">join_queues</a> (<a class="el" href="structutil_1_1mem_1_1PoolQueue.html">QueueType</a> left_queue, <a class="el" href="structutil_1_1mem_1_1PoolQueue.html">QueueType</a> right_queue)</td></tr>
<tr class="separator:a89530a81b85f94a42dc99b074c9cdd5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9f95aaf57b15a8da048ae7320fc5174" id="r_aa9f95aaf57b15a8da048ae7320fc5174"><td class="memItemLeft" align="right" valign="top">__device__ <a class="el" href="#a6c9098c42fa96932d28d5d0f1821a383">LinkAdrType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa9f95aaf57b15a8da048ae7320fc5174">pop_front</a> (<a class="el" href="structutil_1_1mem_1_1PoolQueue.html">QueueType</a> &amp;queue)</td></tr>
<tr class="separator:aa9f95aaf57b15a8da048ae7320fc5174"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4981156b3ceee3e2fc9d7a9f963af76f" id="r_a4981156b3ceee3e2fc9d7a9f963af76f"><td class="memItemLeft" align="right" valign="top">__device__ void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4981156b3ceee3e2fc9d7a9f963af76f">push_back</a> (<a class="el" href="structutil_1_1mem_1_1PoolQueue.html">QueueType</a> &amp;queue, <a class="el" href="#a6c9098c42fa96932d28d5d0f1821a383">LinkAdrType</a> link_adr)</td></tr>
<tr class="separator:a4981156b3ceee3e2fc9d7a9f963af76f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d7652abb56f990c094611f717984fee" id="r_a2d7652abb56f990c094611f717984fee"><td class="memItemLeft" align="right" valign="top">__device__ <a class="el" href="structutil_1_1mem_1_1PoolQueue.html">QueueType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2d7652abb56f990c094611f717984fee">pull_queue</a> (<a class="el" href="structutil_1_1mem_1_1PoolQueue.html">QueueType</a> *src, unsigned int start_index, unsigned int range_size, unsigned int &amp;src_index)</td></tr>
<tr class="separator:a2d7652abb56f990c094611f717984fee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e74a5c95e156cb8e0f5d5dced370c4f" id="r_a9e74a5c95e156cb8e0f5d5dced370c4f"><td class="memItemLeft" align="right" valign="top">__device__ <a class="el" href="structutil_1_1mem_1_1PoolQueue.html">QueueType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9e74a5c95e156cb8e0f5d5dced370c4f">push_queue</a> (<a class="el" href="structutil_1_1mem_1_1PoolQueue.html">QueueType</a> &amp;dest, <a class="el" href="structutil_1_1mem_1_1PoolQueue.html">QueueType</a> &amp;queue)</td></tr>
<tr class="separator:a9e74a5c95e156cb8e0f5d5dced370c4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e87e63820f1842950969ac73fa8942e" id="r_a8e87e63820f1842950969ac73fa8942e"><td class="memItemLeft" align="right" valign="top"><a id="a8e87e63820f1842950969ac73fa8942e" name="a8e87e63820f1842950969ac73fa8942e"></a>
__device__ <a class="el" href="#a6c9098c42fa96932d28d5d0f1821a383">LinkAdrType</a>&#160;</td><td class="memItemRight" valign="bottom"><b>claim_stash_link</b> ()</td></tr>
<tr class="memdesc:a8e87e63820f1842950969ac73fa8942e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Claims a link from the link stash. If no link exists in the stash, LinkAdrType::null is returned. <br /></td></tr>
<tr class="separator:a8e87e63820f1842950969ac73fa8942e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc79b6fdae9eb5427860c8c1021f269a" id="r_abc79b6fdae9eb5427860c8c1021f269a"><td class="memItemLeft" align="right" valign="top">__device__ void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abc79b6fdae9eb5427860c8c1021f269a">insert_stash_link</a> (<a class="el" href="#a6c9098c42fa96932d28d5d0f1821a383">LinkAdrType</a> link)</td></tr>
<tr class="separator:abc79b6fdae9eb5427860c8c1021f269a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a6bfe9c4594e5eb9074c63fbffd3c6c" id="r_a5a6bfe9c4594e5eb9074c63fbffd3c6c"><td class="memItemLeft" align="right" valign="top">__device__ unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5a6bfe9c4594e5eb9074c63fbffd3c6c">claim_empty_slot</a> ()</td></tr>
<tr class="separator:a5a6bfe9c4594e5eb9074c63fbffd3c6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa58245a377c2fcac6d794505ca8ea4d8" id="r_aa58245a377c2fcac6d794505ca8ea4d8"><td class="memItemLeft" align="right" valign="top">__device__ void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa58245a377c2fcac6d794505ca8ea4d8">insert_empty_slot</a> (unsigned int slot)</td></tr>
<tr class="separator:aa58245a377c2fcac6d794505ca8ea4d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a4673989530e889e7ffe4a1be15d724" id="r_a7a4673989530e889e7ffe4a1be15d724"><td class="memItemLeft" align="right" valign="top">__device__ unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7a4673989530e889e7ffe4a1be15d724">claim_full_slot</a> ()</td></tr>
<tr class="separator:a7a4673989530e889e7ffe4a1be15d724"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23027fb2d8bff7f0b6d12d64e2628aa9" id="r_a23027fb2d8bff7f0b6d12d64e2628aa9"><td class="memItemLeft" align="right" valign="top">__device__ void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a23027fb2d8bff7f0b6d12d64e2628aa9">insert_full_slot</a> (<a class="el" href="structAsyncProgram_1_1RemapQueue.html">RemapQueue</a> &amp;queue, unsigned int slot)</td></tr>
<tr class="separator:a23027fb2d8bff7f0b6d12d64e2628aa9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ea112ab08e007b52e08d946a3fda732" id="r_a0ea112ab08e007b52e08d946a3fda732"><td class="memItemLeft" align="right" valign="top">__device__ void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0ea112ab08e007b52e08d946a3fda732">dealloc_links</a> (<a class="el" href="#a6c9098c42fa96932d28d5d0f1821a383">LinkAdrType</a> *src, size_t count)</td></tr>
<tr class="separator:a0ea112ab08e007b52e08d946a3fda732"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4bef5ac613fd0474a148c72dd15a103e" id="r_a4bef5ac613fd0474a148c72dd15a103e"><td class="memItemLeft" align="right" valign="top">__device__ size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4bef5ac613fd0474a148c72dd15a103e">alloc_links</a> (<a class="el" href="#a6c9098c42fa96932d28d5d0f1821a383">LinkAdrType</a> *dst, size_t req_count)</td></tr>
<tr class="separator:a4bef5ac613fd0474a148c72dd15a103e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa58fb49a9bf24957f0f4bf4efb466d77" id="r_aa58fb49a9bf24957f0f4bf4efb466d77"><td class="memItemLeft" align="right" valign="top"><a id="aa58fb49a9bf24957f0f4bf4efb466d77" name="aa58fb49a9bf24957f0f4bf4efb466d77"></a>
__device__ <a class="el" href="#a6c9098c42fa96932d28d5d0f1821a383">LinkAdrType</a>&#160;</td><td class="memItemRight" valign="bottom"><b>alloc_spare_link</b> ()</td></tr>
<tr class="separator:aa58fb49a9bf24957f0f4bf4efb466d77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7e7151278d12538c0a53d462ad508ae" id="r_aa7e7151278d12538c0a53d462ad508ae"><td class="memItemLeft" align="right" valign="top"><a id="aa7e7151278d12538c0a53d462ad508ae" name="aa7e7151278d12538c0a53d462ad508ae"></a>
__device__ void&#160;</td><td class="memItemRight" valign="bottom"><b>dump_spare_link</b> (<a class="el" href="#a6c9098c42fa96932d28d5d0f1821a383">LinkAdrType</a> link_adr)</td></tr>
<tr class="separator:aa7e7151278d12538c0a53d462ad508ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37b294e110a21feb366b3bff7487cd91" id="r_a37b294e110a21feb366b3bff7487cd91"><td class="memItemLeft" align="right" valign="top">__device__ void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a37b294e110a21feb366b3bff7487cd91">fill_stash_links</a> (unsigned int threashold)</td></tr>
<tr class="separator:a37b294e110a21feb366b3bff7487cd91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08128d02b10467ebe22bdd43d3c456dd" id="r_a08128d02b10467ebe22bdd43d3c456dd"><td class="memItemLeft" align="right" valign="top">__device__ void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a08128d02b10467ebe22bdd43d3c456dd">spill_stash_links</a> (unsigned int threashold)</td></tr>
<tr class="separator:a08128d02b10467ebe22bdd43d3c456dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40b48623142ff666f580e8e8af09f165" id="r_a40b48623142ff666f580e8e8af09f165"><td class="memItemLeft" align="right" valign="top">__device__ void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a40b48623142ff666f580e8e8af09f165">pop_frame_counters</a> (unsigned int start_level, unsigned int end_level)</td></tr>
<tr class="separator:a40b48623142ff666f580e8e8af09f165"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe795755b5c17943903671315f71e655" id="r_afe795755b5c17943903671315f71e655"><td class="memItemLeft" align="right" valign="top">__device__ void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afe795755b5c17943903671315f71e655">push_promises</a> (unsigned int level, unsigned int index, <a class="el" href="structutil_1_1mem_1_1PoolQueue.html">QueueType</a> queue, int promise_delta)</td></tr>
<tr class="separator:afe795755b5c17943903671315f71e655"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad38b10c70436a4a468d26cb4355c1a31" id="r_ad38b10c70436a4a468d26cb4355c1a31"><td class="memItemLeft" align="right" valign="top">__device__ <a class="el" href="structutil_1_1mem_1_1PoolQueue.html">QueueType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad38b10c70436a4a468d26cb4355c1a31">pull_promises</a> (unsigned int level, unsigned int &amp;source_index)</td></tr>
<tr class="separator:ad38b10c70436a4a468d26cb4355c1a31"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7db77516ac78bf9bf8cd0388169ae964" id="r_a7db77516ac78bf9bf8cd0388169ae964"><td class="memItemLeft" align="right" valign="top">__device__ <a class="el" href="structutil_1_1mem_1_1PoolQueue.html">QueueType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7db77516ac78bf9bf8cd0388169ae964">pull_promises_any_level</a> (unsigned int &amp;level, unsigned int &amp;source_index)</td></tr>
<tr class="separator:a7db77516ac78bf9bf8cd0388169ae964"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae01c019d386f51aa753ffacc59954233" id="r_ae01c019d386f51aa753ffacc59954233"><td class="memItemLeft" align="right" valign="top">__device__ <a class="el" href="#a6c9098c42fa96932d28d5d0f1821a383">LinkAdrType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae01c019d386f51aa753ffacc59954233">produce_link</a> (unsigned int slot_index)</td></tr>
<tr class="separator:ae01c019d386f51aa753ffacc59954233"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7107e84f8c301a90da78fa849fa643cf" id="r_a7107e84f8c301a90da78fa849fa643cf"><td class="memItemLeft" align="right" valign="top">__device__ void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7107e84f8c301a90da78fa849fa643cf">relevel_stash</a> (unsigned int level)</td></tr>
<tr class="separator:a7107e84f8c301a90da78fa849fa643cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f3b10584757a20fc053bdda0b6af5a8" id="r_a9f3b10584757a20fc053bdda0b6af5a8"><td class="memItemLeft" align="right" valign="top">__device__ void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9f3b10584757a20fc053bdda0b6af5a8">spill_stash</a> (unsigned int threashold)</td></tr>
<tr class="separator:a9f3b10584757a20fc053bdda0b6af5a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abcb56b4fecb80a7e7fe411cf04695b1a" id="r_abcb56b4fecb80a7e7fe411cf04695b1a"><td class="memItemLeft" align="right" valign="top"><a id="abcb56b4fecb80a7e7fe411cf04695b1a" name="abcb56b4fecb80a7e7fe411cf04695b1a"></a>
__device__ void&#160;</td><td class="memItemRight" valign="bottom"><b>async_call_stash_dump</b> (OpDisc func_id, int depth_delta, unsigned int delta)</td></tr>
<tr class="memdesc:abcb56b4fecb80a7e7fe411cf04695b1a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Spills from stash in advance of inserting more work. <br /></td></tr>
<tr class="separator:abcb56b4fecb80a7e7fe411cf04695b1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a450dd678dfd766ed938da294e9cad31e" id="r_a450dd678dfd766ed938da294e9cad31e"><td class="memItemLeft" align="right" valign="top"><a id="a450dd678dfd766ed938da294e9cad31e" name="a450dd678dfd766ed938da294e9cad31e"></a>
__device__ void&#160;</td><td class="memItemRight" valign="bottom"><b>async_call_stash_prep</b> (<a class="el" href="structAsyncProgram_1_1RemapQueue.html">RemapQueue</a> &amp;dst, OpDisc func_id, int depth_delta, unsigned int delta, unsigned int &amp;left, unsigned int &amp;left_start, unsigned int &amp;right)</td></tr>
<tr class="memdesc:a450dd678dfd766ed938da294e9cad31e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prepares the stash for the insertion of work. <br /></td></tr>
<tr class="separator:a450dd678dfd766ed938da294e9cad31e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1bbda03e5ccc5520857b9102393d4bf0" id="r_a1bbda03e5ccc5520857b9102393d4bf0"><td class="memItemLeft" align="right" valign="top"><a id="a1bbda03e5ccc5520857b9102393d4bf0" name="a1bbda03e5ccc5520857b9102393d4bf0"></a>
__device__ void&#160;</td><td class="memItemRight" valign="bottom"><b>async_call</b> (OpDisc func_id, int depth_delta, <a class="el" href="#ad87689d084dfa71a790291153a1192ee">PromiseUnionType</a> &amp;promise)</td></tr>
<tr class="separator:a1bbda03e5ccc5520857b9102393d4bf0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6758028d07971589d8fb7f6518553940" id="r_a6758028d07971589d8fb7f6518553940"><td class="memTemplParams" colspan="2"><a id="a6758028d07971589d8fb7f6518553940" name="a6758028d07971589d8fb7f6518553940"></a>
template&lt;typename TYPE , typename... ARGS&gt; </td></tr>
<tr class="memitem:a6758028d07971589d8fb7f6518553940"><td class="memTemplItemLeft" align="right" valign="top">__device__ void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>async_call_cast</b> (int depth_delta, ARGS... args)</td></tr>
<tr class="separator:a6758028d07971589d8fb7f6518553940"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5fc8734661cba7befcbfa5df23adf21" id="r_ae5fc8734661cba7befcbfa5df23adf21"><td class="memTemplParams" colspan="2"><a id="ae5fc8734661cba7befcbfa5df23adf21" name="ae5fc8734661cba7befcbfa5df23adf21"></a>
template&lt;typename TYPE &gt; </td></tr>
<tr class="memitem:ae5fc8734661cba7befcbfa5df23adf21"><td class="memTemplItemLeft" align="right" valign="top">__device__ void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>async_call_cast</b> (int depth_delta, <a class="el" href="structPromise.html">Promise</a>&lt; TYPE &gt; promise)</td></tr>
<tr class="separator:ae5fc8734661cba7befcbfa5df23adf21"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f29dcc76ef7a7a205f0ffbbf6fa04c3" id="r_a5f29dcc76ef7a7a205f0ffbbf6fa04c3"><td class="memTemplParams" colspan="2"><a id="a5f29dcc76ef7a7a205f0ffbbf6fa04c3" name="a5f29dcc76ef7a7a205f0ffbbf6fa04c3"></a>
template&lt;typename TYPE &gt; </td></tr>
<tr class="memitem:a5f29dcc76ef7a7a205f0ffbbf6fa04c3"><td class="memTemplItemLeft" align="right" valign="top">__device__ void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>immediate_call_cast</b> (<a class="el" href="structPromise.html">Promise</a>&lt; TYPE &gt; param_value)</td></tr>
<tr class="separator:a5f29dcc76ef7a7a205f0ffbbf6fa04c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95750dbc8b38c560404dbb8eadb98e79" id="r_a95750dbc8b38c560404dbb8eadb98e79"><td class="memItemLeft" align="right" valign="top"><a id="a95750dbc8b38c560404dbb8eadb98e79" name="a95750dbc8b38c560404dbb8eadb98e79"></a>
__device__ unsigned int&#160;</td><td class="memItemRight" valign="bottom"><b>consume_link</b> (<a class="el" href="#a6c9098c42fa96932d28d5d0f1821a383">LinkAdrType</a> link_index)</td></tr>
<tr class="separator:a95750dbc8b38c560404dbb8eadb98e79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ef2993a15e1d1d875eaccaca1bde71b" id="r_a0ef2993a15e1d1d875eaccaca1bde71b"><td class="memItemLeft" align="right" valign="top"><a id="a0ef2993a15e1d1d875eaccaca1bde71b" name="a0ef2993a15e1d1d875eaccaca1bde71b"></a>
__device__ void&#160;</td><td class="memItemRight" valign="bottom"><b>fill_stash</b> (unsigned int threashold, bool halt_on_fail)</td></tr>
<tr class="separator:a0ef2993a15e1d1d875eaccaca1bde71b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f8b4c31c45d8f687099282eec010af4" id="r_a8f8b4c31c45d8f687099282eec010af4"><td class="memItemLeft" align="right" valign="top"><a id="a8f8b4c31c45d8f687099282eec010af4" name="a8f8b4c31c45d8f687099282eec010af4"></a>
__device__ void&#160;</td><td class="memItemRight" valign="bottom"><b>clear_exec_head</b> ()</td></tr>
<tr class="separator:a8f8b4c31c45d8f687099282eec010af4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7a7191c286f69d947b8cddef1da8385" id="r_ae7a7191c286f69d947b8cddef1da8385"><td class="memItemLeft" align="right" valign="top"><a id="ae7a7191c286f69d947b8cddef1da8385" name="ae7a7191c286f69d947b8cddef1da8385"></a>
__device__ bool&#160;</td><td class="memItemRight" valign="bottom"><b>advance_stash_iter</b> ()</td></tr>
<tr class="separator:ae7a7191c286f69d947b8cddef1da8385"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d0642e83b8ddb8acfbaca02af6a0ed1" id="r_a0d0642e83b8ddb8acfbaca02af6a0ed1"><td class="memItemLeft" align="right" valign="top"><a id="a0d0642e83b8ddb8acfbaca02af6a0ed1" name="a0d0642e83b8ddb8acfbaca02af6a0ed1"></a>
__device__ void&#160;</td><td class="memItemRight" valign="bottom"><b>exec_cycle</b> ()</td></tr>
<tr class="separator:a0d0642e83b8ddb8acfbaca02af6a0ed1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac277867408d74a0425518064d500990d" id="r_ac277867408d74a0425518064d500990d"><td class="memItemLeft" align="right" valign="top"><a id="ac277867408d74a0425518064d500990d" name="ac277867408d74a0425518064d500990d"></a>
__device__ void&#160;</td><td class="memItemRight" valign="bottom"><b>cleanup_runtime</b> ()</td></tr>
<tr class="separator:ac277867408d74a0425518064d500990d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="friends" name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:a2376d4bac4097cf62f37cc6f3bc28b91" id="r_a2376d4bac4097cf62f37cc6f3bc28b91"><td class="memTemplParams" colspan="2">template&lt;typename OP_SET , typename ADR_TYPE &gt; </td></tr>
<tr class="memitem:a2376d4bac4097cf62f37cc6f3bc28b91"><td class="memTemplItemLeft" align="right" valign="top">class&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a2376d4bac4097cf62f37cc6f3bc28b91">RemappingBarrier</a></td></tr>
<tr class="memdesc:a2376d4bac4097cf62f37cc6f3bc28b91"><td class="mdescLeft">&#160;</td><td class="mdescRight">Define the type used to address work links.  <br /></td></tr>
<tr class="separator:a2376d4bac4097cf62f37cc6f3bc28b91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab136a134f9c4af3bfc93787c40dc3439" id="r_ab136a134f9c4af3bfc93787c40dc3439"><td class="memTemplParams" colspan="2"><a id="ab136a134f9c4af3bfc93787c40dc3439" name="ab136a134f9c4af3bfc93787c40dc3439"></a>
template&lt;typename... TYPES&gt; </td></tr>
<tr class="memitem:ab136a134f9c4af3bfc93787c40dc3439"><td class="memTemplItemLeft" align="right" valign="top">class&#160;</td><td class="memTemplItemRight" valign="bottom"><b>ArgTuple</b></td></tr>
<tr class="separator:ab136a134f9c4af3bfc93787c40dc3439"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><div class="compoundTemplParams">template&lt;typename PROGRAM_SPEC&gt;<br />
class AsyncProgram&lt; PROGRAM_SPEC &gt;</div><p>The class that defines an asynchronous program and all of its types. </p>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="ad87689d084dfa71a790291153a1192ee" name="ad87689d084dfa71a790291153a1192ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad87689d084dfa71a790291153a1192ee">&#9670;&#160;</a></span>PromiseUnionType</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PROGRAM_SPEC &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="unionPromiseUnion.html">PromiseUnion</a>&lt;OpSet&gt; <a class="el" href="classAsyncProgram.html">AsyncProgram</a>&lt; PROGRAM_SPEC &gt;::PromiseUnionType</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Define the states stored in global, shared, and private memory. </p>
<p>Define the type of <code><a class="el" href="unionPromiseUnion.html">PromiseUnion</a></code> used by the program. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a4bef5ac613fd0474a148c72dd15a103e" name="a4bef5ac613fd0474a148c72dd15a103e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4bef5ac613fd0474a148c72dd15a103e">&#9670;&#160;</a></span>alloc_links()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PROGRAM_SPEC &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">__device__ size_t <a class="el" href="classAsyncProgram.html">AsyncProgram</a>&lt; PROGRAM_SPEC &gt;::alloc_links </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#a6c9098c42fa96932d28d5d0f1821a383">LinkAdrType</a> *</td>          <td class="paramname"><span class="paramname"><em>dst</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>req_count</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>A thread-safe way of allocating links from global memory. This function is used by the warp leader to restock the link stash in between processing promises and used by individual threads if its current promise needs to use a link while the link stash is empty. </p>
<p>Attempt to pull a queue from the pool. This should be very unlikely to fail unless almost all links have been exhausted or the pool size is disproportionately small relative to the number of work groups. In the worst case, this should simply not al_thd_ctxate any links, and the return value shall report this.</p>
<p>Keep popping links from the queue until the full number of links have been added or the queue runs out of links.</p>

</div>
</div>
<a id="a5a6bfe9c4594e5eb9074c63fbffd3c6c" name="a5a6bfe9c4594e5eb9074c63fbffd3c6c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5a6bfe9c4594e5eb9074c63fbffd3c6c">&#9670;&#160;</a></span>claim_empty_slot()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PROGRAM_SPEC &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">__device__ unsigned int <a class="el" href="classAsyncProgram.html">AsyncProgram</a>&lt; PROGRAM_SPEC &gt;::claim_empty_slot </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Claims an empty slot from the stash and returns its index. If no empty slot exists in the stash, then STASH_SIZE is returned. </p>

</div>
</div>
<a id="a7a4673989530e889e7ffe4a1be15d724" name="a7a4673989530e889e7ffe4a1be15d724"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7a4673989530e889e7ffe4a1be15d724">&#9670;&#160;</a></span>claim_full_slot()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PROGRAM_SPEC &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">__device__ unsigned int <a class="el" href="classAsyncProgram.html">AsyncProgram</a>&lt; PROGRAM_SPEC &gt;::claim_full_slot </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Claims a full slot from the stash and returns its index. If no empty slot exists in the stash, then STASH_SIZE is returned. </p>

</div>
</div>
<a id="a0ea112ab08e007b52e08d946a3fda732" name="a0ea112ab08e007b52e08d946a3fda732"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0ea112ab08e007b52e08d946a3fda732">&#9670;&#160;</a></span>dealloc_links()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PROGRAM_SPEC &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">__device__ void <a class="el" href="classAsyncProgram.html">AsyncProgram</a>&lt; PROGRAM_SPEC &gt;::dealloc_links </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#a6c9098c42fa96932d28d5d0f1821a383">LinkAdrType</a> *</td>          <td class="paramname"><span class="paramname"><em>src</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>count</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Connect all links into a queue</p>
<p>Push out the queue to the pool</p>

</div>
</div>
<a id="a37b294e110a21feb366b3bff7487cd91" name="a37b294e110a21feb366b3bff7487cd91"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a37b294e110a21feb366b3bff7487cd91">&#9670;&#160;</a></span>fill_stash_links()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PROGRAM_SPEC &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">__device__ void <a class="el" href="classAsyncProgram.html">AsyncProgram</a>&lt; PROGRAM_SPEC &gt;::fill_stash_links </td>
          <td>(</td>
          <td class="paramtype">unsigned int</td>          <td class="paramname"><span class="paramname"><em>threashold</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Attempts to fill the link stash to the given threshold with links. This should only ever be called in a single-threaded manner. </p>

</div>
</div>
<a id="a935f3320a31e95f2008254702cabb0ca" name="a935f3320a31e95f2008254702cabb0ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a935f3320a31e95f2008254702cabb0ca">&#9670;&#160;</a></span>highest_level()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PROGRAM_SPEC &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">__device__ unsigned int <a class="el" href="classAsyncProgram.html">AsyncProgram</a>&lt; PROGRAM_SPEC &gt;::highest_level </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the current highest level in the stack. Given that this program is highly parallel, this number inherently cannot be trusted. By the time the value is fetched, the stack could have a different height or the thread that set the height may not have deposited links in the corresponding level yet. </p>

</div>
</div>
<a id="a93cae7f0050d7a20eace3bb0a9593c19" name="a93cae7f0050d7a20eace3bb0a9593c19"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a93cae7f0050d7a20eace3bb0a9593c19">&#9670;&#160;</a></span>init_group()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PROGRAM_SPEC &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">__device__ void <a class="el" href="classAsyncProgram.html">AsyncProgram</a>&lt; PROGRAM_SPEC &gt;::init_group </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Initializes the shared state of a work group, which is stored as a ctx_shared struct. This is mainly done by initializing handles to the arena, pool, and stack, setting the current level to null, setting the stash iterator to null, and zeroing the stash. </p>

</div>
</div>
<a id="a74f486fe485fe183c65337e85d44b52d" name="a74f486fe485fe183c65337e85d44b52d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a74f486fe485fe183c65337e85d44b52d">&#9670;&#160;</a></span>init_thread()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PROGRAM_SPEC &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">__device__ void <a class="el" href="classAsyncProgram.html">AsyncProgram</a>&lt; PROGRAM_SPEC &gt;::init_thread </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Initializes the local state of a thread, which is just the device id of the thread and the state used by the thread to generate random numbers for stochastic choices needed to manage the runtime state. </p>

</div>
</div>
<a id="aa58245a377c2fcac6d794505ca8ea4d8" name="aa58245a377c2fcac6d794505ca8ea4d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa58245a377c2fcac6d794505ca8ea4d8">&#9670;&#160;</a></span>insert_empty_slot()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PROGRAM_SPEC &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">__device__ void <a class="el" href="classAsyncProgram.html">AsyncProgram</a>&lt; PROGRAM_SPEC &gt;::insert_empty_slot </td>
          <td>(</td>
          <td class="paramtype">unsigned int</td>          <td class="paramname"><span class="paramname"><em>slot</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Inserts an empty slot into the stash. This should only be called if there is enough space in the link stash. </p>

</div>
</div>
<a id="a23027fb2d8bff7f0b6d12d64e2628aa9" name="a23027fb2d8bff7f0b6d12d64e2628aa9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a23027fb2d8bff7f0b6d12d64e2628aa9">&#9670;&#160;</a></span>insert_full_slot()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PROGRAM_SPEC &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">__device__ void <a class="el" href="classAsyncProgram.html">AsyncProgram</a>&lt; PROGRAM_SPEC &gt;::insert_full_slot </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structAsyncProgram_1_1RemapQueue.html">RemapQueue</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>queue</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int</td>          <td class="paramname"><span class="paramname"><em>slot</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Inserts a full slot into the stash. This should only be called if there is enough space in the link stash. </p>

</div>
</div>
<a id="abc79b6fdae9eb5427860c8c1021f269a" name="abc79b6fdae9eb5427860c8c1021f269a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abc79b6fdae9eb5427860c8c1021f269a">&#9670;&#160;</a></span>insert_stash_link()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PROGRAM_SPEC &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">__device__ void <a class="el" href="classAsyncProgram.html">AsyncProgram</a>&lt; PROGRAM_SPEC &gt;::insert_stash_link </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#a6c9098c42fa96932d28d5d0f1821a383">LinkAdrType</a></td>          <td class="paramname"><span class="paramname"><em>link</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Inserts an empty slot into the stash. This should only be called if there is enough space in the link stash. </p>

</div>
</div>
<a id="a89530a81b85f94a42dc99b074c9cdd5c" name="a89530a81b85f94a42dc99b074c9cdd5c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a89530a81b85f94a42dc99b074c9cdd5c">&#9670;&#160;</a></span>join_queues()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PROGRAM_SPEC &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">__device__ <a class="el" href="structutil_1_1mem_1_1PoolQueue.html">QueueType</a> <a class="el" href="classAsyncProgram.html">AsyncProgram</a>&lt; PROGRAM_SPEC &gt;::join_queues </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structutil_1_1mem_1_1PoolQueue.html">QueueType</a></td>          <td class="paramname"><span class="paramname"><em>left_queue</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structutil_1_1mem_1_1PoolQueue.html">QueueType</a></td>          <td class="paramname"><span class="paramname"><em>right_queue</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Joins two queues such that the right queue is now at the end of the left queue.</p>
<p>WARNING: NOT THREAD SAFE. Only use this on queues that have been claimed from the stack atomically. If not, one of the queues manipulated with this function will almost certainly become malformed at some point. </p>
<p>Find last link in the queue referenced by left_queue.</p>
<p>Set the index for the tail's successor to the head of the queue referenced by right_queue.</p>
<p>Set the right half of the left_queue handle to index the new tail.</p>

</div>
</div>
<a id="a017c798fcb9de528856ae3f2b8554122" name="a017c798fcb9de528856ae3f2b8554122"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a017c798fcb9de528856ae3f2b8554122">&#9670;&#160;</a></span>partial_map_index()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PROGRAM_SPEC &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">__device__ unsigned int <a class="el" href="classAsyncProgram.html">AsyncProgram</a>&lt; PROGRAM_SPEC &gt;::partial_map_index </td>
          <td>(</td>
          <td class="paramtype">OpDisc</td>          <td class="paramname"><span class="paramname"><em>func_id</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int</td>          <td class="paramname"><span class="paramname"><em>depth</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int</td>          <td class="paramname"><span class="paramname"><em>current_level</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns an index into the partial map of a group based off of a function id and a depth. If an invalid depth or function id is used, PART_ENTRY_COUNT is returned. </p>

</div>
</div>
<a id="a40b48623142ff666f580e8e8af09f165" name="a40b48623142ff666f580e8e8af09f165"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a40b48623142ff666f580e8e8af09f165">&#9670;&#160;</a></span>pop_frame_counters()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PROGRAM_SPEC &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">__device__ void <a class="el" href="classAsyncProgram.html">AsyncProgram</a>&lt; PROGRAM_SPEC &gt;::pop_frame_counters </td>
          <td>(</td>
          <td class="paramtype">unsigned int</td>          <td class="paramname"><span class="paramname"><em>start_level</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int</td>          <td class="paramname"><span class="paramname"><em>end_level</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Decrements the child and resident counter of each frame corresponding to a call at level start_level in the stack returning to a continuation at level end_level in the stack. To reduce overall contention, decrementations are first pooled through a shared atomic operation before being applied to the stack. A call without a continuation should use this function with start_level == end_level, which simply decrements the resident counter at the call's frame. </p>
<p>Decrement the residents counter for the start level</p>
<p>Decrement the children counter for the remaining levels</p>
<p>Update the stack base once all other counters have been updated.</p>

</div>
</div>
<a id="aa9f95aaf57b15a8da048ae7320fc5174" name="aa9f95aaf57b15a8da048ae7320fc5174"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa9f95aaf57b15a8da048ae7320fc5174">&#9670;&#160;</a></span>pop_front()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PROGRAM_SPEC &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">__device__ <a class="el" href="#a6c9098c42fa96932d28d5d0f1821a383">LinkAdrType</a> <a class="el" href="classAsyncProgram.html">AsyncProgram</a>&lt; PROGRAM_SPEC &gt;::pop_front </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structutil_1_1mem_1_1PoolQueue.html">QueueType</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>queue</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Takes the first link off of the queue and returns the index of the link in the arena. If the queue is empty, a null address is returned instead.</p>
<p>WARNING: NOT THREAD SAFE. Only use this on queues that have been claimed from the stack atomically. If not, one of the queues manipulated with this function will almost certainly become malformed at some point. </p>
<p>Don't try unless the queue is non-null</p>

</div>
</div>
<a id="ae01c019d386f51aa753ffacc59954233" name="ae01c019d386f51aa753ffacc59954233"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae01c019d386f51aa753ffacc59954233">&#9670;&#160;</a></span>produce_link()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PROGRAM_SPEC &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">__device__ <a class="el" href="#a6c9098c42fa96932d28d5d0f1821a383">LinkAdrType</a> <a class="el" href="classAsyncProgram.html">AsyncProgram</a>&lt; PROGRAM_SPEC &gt;::produce_link </td>
          <td>(</td>
          <td class="paramtype">unsigned int</td>          <td class="paramname"><span class="paramname"><em>slot_index</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Adds the contents of the stash slot at the given index to a link and returns the index of the link in the arena. This should only ever be called if there is both a link available to store the data and if the index is pointing at a non-empty slot. This also should only ever be called in a single-threaded context. </p>

</div>
</div>
<a id="ad38b10c70436a4a468d26cb4355c1a31" name="ad38b10c70436a4a468d26cb4355c1a31"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad38b10c70436a4a468d26cb4355c1a31">&#9670;&#160;</a></span>pull_promises()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PROGRAM_SPEC &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">__device__ <a class="el" href="structutil_1_1mem_1_1PoolQueue.html">QueueType</a> <a class="el" href="classAsyncProgram.html">AsyncProgram</a>&lt; PROGRAM_SPEC &gt;::pull_promises </td>
          <td>(</td>
          <td class="paramtype">unsigned int</td>          <td class="paramname"><span class="paramname"><em>level</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int &amp;</td>          <td class="paramname"><span class="paramname"><em>source_index</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Attempts to pull a queue of promises from the frame in the stack of the given level, starting the pull attempt at the given index in the frame. If no queue could be pulled after attempting a pull at each queue in the given frame, a QueueType::null value is returned. </p>

</div>
</div>
<a id="a7db77516ac78bf9bf8cd0388169ae964" name="a7db77516ac78bf9bf8cd0388169ae964"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7db77516ac78bf9bf8cd0388169ae964">&#9670;&#160;</a></span>pull_promises_any_level()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PROGRAM_SPEC &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">__device__ <a class="el" href="structutil_1_1mem_1_1PoolQueue.html">QueueType</a> <a class="el" href="classAsyncProgram.html">AsyncProgram</a>&lt; PROGRAM_SPEC &gt;::pull_promises_any_level </td>
          <td>(</td>
          <td class="paramtype">unsigned int &amp;</td>          <td class="paramname"><span class="paramname"><em>level</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int &amp;</td>          <td class="paramname"><span class="paramname"><em>source_index</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Attempts to pull a queue from any frame in the stack, starting from the highest and working its way down. If no queue could be pulled, a QueueType::null value is returned. </p>

</div>
</div>
<a id="a2d7652abb56f990c094611f717984fee" name="a2d7652abb56f990c094611f717984fee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2d7652abb56f990c094611f717984fee">&#9670;&#160;</a></span>pull_queue()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PROGRAM_SPEC &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">__device__ <a class="el" href="structutil_1_1mem_1_1PoolQueue.html">QueueType</a> <a class="el" href="classAsyncProgram.html">AsyncProgram</a>&lt; PROGRAM_SPEC &gt;::pull_queue </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structutil_1_1mem_1_1PoolQueue.html">QueueType</a> *</td>          <td class="paramname"><span class="paramname"><em>src</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int</td>          <td class="paramname"><span class="paramname"><em>start_index</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int</td>          <td class="paramname"><span class="paramname"><em>range_size</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int &amp;</td>          <td class="paramname"><span class="paramname"><em>src_index</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Attempts to pull a queue from a range of queue slots, trying each slot starting from the given starting index onto the end of the range and then looping back from the beginning. If, after trying every slot in the range, no non-null queue was obtained, a QueueType::null value is returned. </p>
<p>First iterate from the starting index to the end of the queue range, attempting to claim a non-null queue until either there are no more slots to try, or the atomic swap successfuly retrieves something.</p>
<p>Continue searching from the beginning of the range to just before the beginning of the previous scan.</p>
<p><a class="el" href="structReturn.html">Return</a> QueueType::null if nothing is found</p>

</div>
</div>
<a id="a4981156b3ceee3e2fc9d7a9f963af76f" name="a4981156b3ceee3e2fc9d7a9f963af76f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4981156b3ceee3e2fc9d7a9f963af76f">&#9670;&#160;</a></span>push_back()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PROGRAM_SPEC &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">__device__ void <a class="el" href="classAsyncProgram.html">AsyncProgram</a>&lt; PROGRAM_SPEC &gt;::push_back </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structutil_1_1mem_1_1PoolQueue.html">QueueType</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>queue</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a6c9098c42fa96932d28d5d0f1821a383">LinkAdrType</a></td>          <td class="paramname"><span class="paramname"><em>link_adr</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Adds the given link to the end of the given queue. This link can NOT be part of another queue, and its next pointer will be automatically nulled before it is appended. If you need to merge two queues together, use join_queues.</p>
<p>WARNING: NOT THREAD SAFE. Only use this on queues that have been claimed from the stack atomically. If not, one of the queues manipulated with this function will almost certainly become malformed at some point. </p>

</div>
</div>
<a id="afe795755b5c17943903671315f71e655" name="afe795755b5c17943903671315f71e655"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afe795755b5c17943903671315f71e655">&#9670;&#160;</a></span>push_promises()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PROGRAM_SPEC &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">__device__ void <a class="el" href="classAsyncProgram.html">AsyncProgram</a>&lt; PROGRAM_SPEC &gt;::push_promises </td>
          <td>(</td>
          <td class="paramtype">unsigned int</td>          <td class="paramname"><span class="paramname"><em>level</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int</td>          <td class="paramname"><span class="paramname"><em>index</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structutil_1_1mem_1_1PoolQueue.html">QueueType</a></td>          <td class="paramname"><span class="paramname"><em>queue</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>promise_delta</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Repetitively tries to merge the given queue of promises with the queue at the given index in the frame at the given level on the stack. This function currently aborts if an error flag is set or if too many merge failures occur, however, once its correctness is verified, this function will run forever until the merge is successful, as success is essentially guaranteed by the nature of the process. </p>
<p>Do not bother pushing a null queue if there is no delta to report</p>
<p>Change the resident counter of the destination frame by the number of promises that have been added to or removed from the given queue</p>
<p>If the addition caused a frame to change from empty to non-empty or vice-versa, make an appropriate incrementation or decrementation at the stack base.</p>
<p>Finally, push the queues</p>

</div>
</div>
<a id="a9e74a5c95e156cb8e0f5d5dced370c4f" name="a9e74a5c95e156cb8e0f5d5dced370c4f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9e74a5c95e156cb8e0f5d5dced370c4f">&#9670;&#160;</a></span>push_queue()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PROGRAM_SPEC &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">__device__ <a class="el" href="structutil_1_1mem_1_1PoolQueue.html">QueueType</a> <a class="el" href="classAsyncProgram.html">AsyncProgram</a>&lt; PROGRAM_SPEC &gt;::push_queue </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structutil_1_1mem_1_1PoolQueue.html">QueueType</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>dest</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structutil_1_1mem_1_1PoolQueue.html">QueueType</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>queue</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Repeatedly tries to push a queue to a destination queue slot by atomic exchanges. If a non null queue is ever returned by the exchange, it attempts to merge with a subsequent exchange.</p>
<p>If an invalid queue (one half null, the other half non-null) is ever found at the destination, the value of that invalid queue is returned, the invalid value is replaced into the queue, and any work gathered from the replacement is assigned to the second argument. Otherwise, the second argument is set to a null state. </p>
<p>If our swap returns a non-null queue, we are still stuck with a queue that needs to be offloaded to the stack. In this case, claim the queue from the slot just swapped with, merge the two, and attempt again to place the queue back. With this method, swap failures are bounded by the number of pushes to the queue slot, with at most one failure per push_queue call, but no guarantee of which attempt from which call will suffer from an incurred failure.</p>

</div>
</div>
<a id="a7107e84f8c301a90da78fa849fa643cf" name="a7107e84f8c301a90da78fa849fa643cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7107e84f8c301a90da78fa849fa643cf">&#9670;&#160;</a></span>relevel_stash()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PROGRAM_SPEC &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">__device__ void <a class="el" href="classAsyncProgram.html">AsyncProgram</a>&lt; PROGRAM_SPEC &gt;::relevel_stash </td>
          <td>(</td>
          <td class="paramtype">unsigned int</td>          <td class="paramname"><span class="paramname"><em>level</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Removes all promises in the stash that do not correspond to the given level, or to the levels immediately above or below (level+1) and (level-1). </p>

</div>
</div>
<a id="a9f3b10584757a20fc053bdda0b6af5a8" name="a9f3b10584757a20fc053bdda0b6af5a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9f3b10584757a20fc053bdda0b6af5a8">&#9670;&#160;</a></span>spill_stash()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PROGRAM_SPEC &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">__device__ void <a class="el" href="classAsyncProgram.html">AsyncProgram</a>&lt; PROGRAM_SPEC &gt;::spill_stash </td>
          <td>(</td>
          <td class="paramtype">unsigned int</td>          <td class="paramname"><span class="paramname"><em>threashold</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Dumps all full links not corresponding to the current execution level. Furthermore, should the remaining links still put the stash over the given threshold occupancy, links will be further removed in the order: full links at the current level, partial links not at the current level, partial links at the current level. </p>

</div>
</div>
<a id="a08128d02b10467ebe22bdd43d3c456dd" name="a08128d02b10467ebe22bdd43d3c456dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a08128d02b10467ebe22bdd43d3c456dd">&#9670;&#160;</a></span>spill_stash_links()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PROGRAM_SPEC &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">__device__ void <a class="el" href="classAsyncProgram.html">AsyncProgram</a>&lt; PROGRAM_SPEC &gt;::spill_stash_links </td>
          <td>(</td>
          <td class="paramtype">unsigned int</td>          <td class="paramname"><span class="paramname"><em>threashold</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>If the number of links in the link stash exceeds the given threshold value, this function frees enough links to bring the number of links down to the threshold. This should only ever be called in a single_threaded manner. </p>
<p>Do not even try if no links can be or need to be removed</p>
<p>Find where in the link stash to begin removing links</p>
<p>Connect all links into a queue</p>
<p>Push out the queue to the pool</p>

</div>
</div>
<h2 class="groupheader">Friends And Related Symbol Documentation</h2>
<a id="a2376d4bac4097cf62f37cc6f3bc28b91" name="a2376d4bac4097cf62f37cc6f3bc28b91"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2376d4bac4097cf62f37cc6f3bc28b91">&#9670;&#160;</a></span>RemappingBarrier</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PROGRAM_SPEC &gt; </div>
<div class="memtemplate">
template&lt;typename OP_SET , typename ADR_TYPE &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">friend class <a class="el" href="structRemappingBarrier.html">RemappingBarrier</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Define the type used to address work links. </p>
<p>Define the set of operations </p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a5f1b32e36f3b762455b1ba955ed026fb" name="a5f1b32e36f3b762455b1ba955ed026fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f1b32e36f3b762455b1ba955ed026fb">&#9670;&#160;</a></span>PUSH_QUEUE_RETRY_LIMIT</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PROGRAM_SPEC &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const unsigned int <a class="el" href="classAsyncProgram.html">AsyncProgram</a>&lt; PROGRAM_SPEC &gt;::PUSH_QUEUE_RETRY_LIMIT = 32</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>During system verification/debugging, this will be used as a cutoff to prevent infinite looping </p>

</div>
</div>
<a id="acacc3e33ace53657a282efe324d6fe5f" name="acacc3e33ace53657a282efe324d6fe5f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acacc3e33ace53657a282efe324d6fe5f">&#9670;&#160;</a></span>STASH_MARGIN</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PROGRAM_SPEC &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const size_t <a class="el" href="classAsyncProgram.html">AsyncProgram</a>&lt; PROGRAM_SPEC &gt;::STASH_MARGIN = 2</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Define internal constants based off of the program specification, or fall back onto defaults. Constants used to determine when to spill or fill the stash, and by how much </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>harmonize/cpp/program/<a class="el" href="async_8h_source.html">async.h</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="classAsyncProgram.html">AsyncProgram</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.12.0 </li>
  </ul>
</div>
</body>
</html>
